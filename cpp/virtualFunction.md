<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-20
-->

# 多态 - 虚函数

## 多态

同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应取决于调用方法的对象。这种较复杂的行为被称为多态 --- 具有多重形态。

有两种方法实现多态：

1. 在派生类中重定义基类的函数；

2. 使用虚函数；

## 虚函数

使用 virtual 说明符修饰的成员函数被称为虚函数。

virtual 说明符指定非静态成员函数为虚函数并支持动态调用派发。它只能在非静态成员函数的首个声明（即当它在类定义中声明时）的声明说明符序列中出现。

虚函数是其行为可以在派生类中覆盖的成员函数。与非虚函数相反，即使没有关于该类实际类型的编译时信息，进行覆盖的行为仍然保留。当使用到基类的指针或引用来处理派生类时，对被覆盖的虚函数的调用，将会调用定义于派生类中的行为。这种函数调用被称为虚函数调用或虚调用。虚函数调用在使用有限定名字查找（即函数名出现在作用域解析运算符 :: 的右侧）时被抑制。

## 虚函数的工作原理

编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针，该指针一般存储在类的最开始的地方。这种数组称为虚函数表 (virtual function table, vtbl)。

虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该 vtbl 将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到 vtbl 中。

注意，vtbl 保存在只读数据段中。无论类中包含的虚函数是 1 个还是 10 个，都只需要在对象中添加 1 个地址成员，只是表的大小不同而已。

调用虚函数时，程序将查看存储在对象中的 vtbl 地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个虚函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。

总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：

* 每个对象都将增大，增大量为存储地址的空间。

* 对于每个类，编译器都创建一个虚函数地址表(数组)。

* 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

## 虚函数的注意事项

* 在基类方法的声明中使用关键字 virtual 可使该方法在基类以及所有的派生类 (包括从派生类派生出来的类) 中是虚的。

* 如果使用指向对象的引用或指针来调用虚函数方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。

* 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。

其他关于虚函数的知识：

1. 构造函数

构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。

2. 析构函数

析构函数应当是虚函数，除非类不用做基类。例如，假设 Employee 是基类，Singer 是派生类，并添加一个 char* 成员，该成员指向由 new 分配的内存。当 Singer 对象过期时，必须调用 ~Singer() 析构函数来释放内存。

```cpp
Employee *pe = new Singer;
...
delete pe;
```

如果使用默认的静态联编，delete 语句将调用 ~Employee() 析构函数。这将释放由 Singer 对象中的 Employee 部分指向的内存，但不会释放新的类成员指向的内存。但如果析构函数是虚的，则上述代码将先调用 ~Singer 析构函数释放由 Singer 组件指向的内存，然后，调用 ~Employee() 析构函数来释放由 Employee 组件指向的内存。

这意味着，即使基类不需要显示虚构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作：

```cpp
virtual ~BaseClass() { }
```

注意：给类定义一个虚析构函数并非错误，即使这个类不用做基类，这只是一个效率方面的问题。

3. 友元

友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。

4. 没有重新定义

如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本。

5. 重定义将隐藏方法

假设创建了如下所示的代码：

```cpp
class Dwelling 
{
public:
    virtual void showperkes(int a) const;
    ...
};

class Hovel : public Dwelling
{
public:
    virtual void showperkes() const;
    ...
};
```

这将导致问题，可能会出现类似下面这样的编译器警告：

`Warning: Hovel::showperkes(void) hides Dwelling::showperkes(int)`

也可能不会出现警告。但不管结果怎样，代码将具有如下定义：

```cpp
Hovel trump;
trump.showperkes();     // valid
trump.showperkes(5);    // invalid
```

新定义将 showperkes() 定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是隐藏了接受一个 int 参数的基类版本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名的基类函数。

这引出了两条经验规则：第一，如果重新定义继承的虚方法，应确保与原来的原型完全相同，但如果返回类型是基类的引用或指针，则可以修改为指向派生类的引用或指针(这种例外是新出现的)。这种特性被称为返回类型协变 (convariance of return type)，因为允许返回值类型随类类型的变化而变化：

```cpp
class Dwelling
{
public:
    virtual Dwelling & build(int n);
    ...
};
class Hovel
{
public:
    virtual Hovel & build(int n);
    ...
};
```

注意，这种例外值适用于返回值，而不适用于参数。

第二，如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。

```cpp
class Dwelling
{
public:
    virtual void showperkes(int n) const;
    virtual void showperkes(double n) const;
    virtual void showperkes() const;
    ...
};
class Hovel : public Dwelling
{
public:
    virtual void showperkes(int n) const;
    virtual void showperkes(double n) const;
    virtual void showperkes() const;
    ...
};
```

如果只重新定义一个新版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。注意，如果不需要修改，则新定义的可只调用基类版本：

```cpp
void Hovel::showperkes() const
{
    Dwelling::showperkes();
}
```

## 问题

### 如何调用基类的虚函数？

指明域就可以了，这时就变成了静态绑定了。例如：

```cpp
class Base
{
public:
    virtual void fun()
    {
        std::cout << "Base::fun()\n";
    }
};

class Derived : public Base
{
public:
    virtual void fun()
    {
        std::cout << "Derived::fun()\n";
    }
};

int main(int argc, char const *argv[])
{
    Base *b = new Derived();
    b->fun();           // calling Derived::fun()
    b->Base::fun();     // calling Base::fun()
    return 0;
}
```

## 引用

1. 《c++ Primer Plus (第 6 版) 中文版》第 13.4.2 节