<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-07-31
-->

# 传输控制协议 (TCP)

TCP (Transmission Control Protocol) 为应用层提供一种面向连接、可靠的字节流服务。

在对数据的完整性和确定性要求较高的情况下需要使用 TCP，如文件传输、邮件等。

TCP 通过下列方式来提供可靠性。三次握手，四次挥手，数据分段、排序、校验(差错丢弃不确认)，消息确认(延时确认，200ms)，超时重传，丢弃重复报文段，流量控制(窗口大小)。

## TCP 首部 (TCP Header)

TCP 数据被封装在一个 IP 数据报中:

```txt
    +-------------------------------------------------+
    | IP Header (20 B) | TCP Header (20 B) | TCP Data 
    +-------------------------------------------------+
```

TCP 首部格式 (TCP Header Format):

```txt
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Source Port          |       Destination Port        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        Sequence Number                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    Acknowledgment Number                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Data |           |U|A|P|R|S|F|                               |
    | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
    |       |           |G|K|H|T|N|N|                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           Checksum            |         Urgent Pointer        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    Options                    |    Padding    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             data                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                           TCP Header Format
```

* Source Port:  16 位源端口号

源端口号用于寻找发端的应用进程。

* Destination Port: 16 位目的端口号

目的端口号用于寻找收端的应用进程。

* Sequence Number: 32 位序号

序号用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用序号对每个字节进行计数。序号是 32 bit的无符号数，序号到达 2^32-1 后又从 0 开始。

当建立一个新的连接时，SYN 标志变 1。序号字段包含由这个主机选择的该连接的初始序号 ISN (Initial Sequence Number)。该主机要发送数据的第一个字节序号是这个 ISN 加 1，因为 SYN 标志消耗了一个序号。

* Acknowledgment Number: 32 位确认序号

每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有 ACK 标志为 1 时确认序号字段才有效。

发送 ACK 无需任何代价，因为 32 bit的确认序号字段和 ACK 标志一样，总是 TCP 首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK 标志也总是被设置为 1。

* Data Offset: 4 位数据偏移，也称首部长度

数据偏移给出首部中 32 bit 字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4位，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是20字节。

* Reserved: 6 位保留

* Control: 6 个控制位  

控制位|解释
:-:|:-:
URG|紧急指针 (urgent pointer)
ACK|确认序号有效
PSH|接收方应尽快将这个报文段交给应用层
RST|重建连接
SYN|同步序号，用来发启一个连接
FIN|发送端完成发送任务

* Window: 16 位窗口大小

TCP 的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16 bit 字段，因而窗口大小最大为 65535 字节。

* Checksum: 16 位校验和

检验和覆盖了整个的 TCP 报文段，TCP 首部和 TCP 数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

* Urgent Pointer: 16 位紧急指针

只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。

* Options: 最大 40 字节的可选字段

最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

* data: 数据部分

## TCP 状态图

```txt
                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+<---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |
   | --------------   snd ACK   |                           ------- |
   V        x                   V                           snd FIN V
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
   |  -------              x       V    ------------        x       V
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
```

## TCP 建立连接 (Establishing a connection)

TCP 建立连接需要告知对方自己的初始序号，并确认对方已经收到。如果建立连接小于三次握手，至多只有请求端的初始序号被确认，服务器的初始序号得不到确认。因此建立一个 TCP 连接需要三次握手。

另外三次握手可以防止已失效的连接请求连接报文段又传输到了服务器。

例如，客户端发送一个连接请求 SYN 段到服务器，由于网络阻塞等原因，服务器没收到此 SYN；于是客户端重传 SYN，连接成功并数据传输完毕后，关闭了 TCP 连接；在关闭连接后，如果客户端发出的第一个 SYN 在某个时间才到达服务器，此时服务器误认为客户端又发出一次连接请求，于是向客户端发出自己的 SYN + ACK 段；如果不采用三次握手，此时服务器就已经建立新的连接了，然而客户端并不会响应服务器的 ACK，且不会发送数据，则服务器一直等待，浪费资源。

### 三次握手 (Three-way handshake)

建立一个 TCP 连接需要三次握手，发送第一个 SYN 的一端将执行主动打开 (active open)。接收这个 SYN 的一端将执行被动打开 (passive open)。

```txt
      TCP A                                                TCP B

  1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED

          Basic 3-Way Handshake for Connection Synchronization
```

第 1 次握手，请求端发送一个 SYN 段指明客户打算连接的服务器的端口，以及初始序号 (ISN)。请求端进入 SYN-SEND 状态，等待服务端确认。

第 2 次握手，服务器发回包含服务器的初始序号的 SYN 报文段作为应答。同时，将确认序号设置为客户的 ISN 加 1 以对客户的 SYN 报文段进行确认，一个 SYN 将占用一个序号。服务端进入 SYN-RECD 状态，等待客户端确认。

第 3 次握手，请求端将确认序号设置为服务器的 ISN 加 1 以对服务器的 SYN 报文段进行确认。

### 同时初始化 (Simultaneous initiation)

两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个 SYN，且这些 SYN 必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。这又称为同时打开 (simultaneous open)。

```txt
      TCP A                                            TCP B

  1.  CLOSED                                           CLOSED

  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...

  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT

  4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED

  5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...

  6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED

  7.               ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED

                Simultaneous Connection Synchronization
```

### 初始序号 (ISN, Initial Sequence Number)

ISN 随时间的变化，因此每个连接都将拥有不同的 ISN，RFC 793 指出 ISN 可以看作是一个 32 比特的计数器，每 4ms 加 1。

在 4.4BSD (和多数伯克利的实现版) 中，系统初始化时初始序号被初始化为 1。这种方法违背了 Host Requirements RFC (在这个代码中的一个注释确认这是一个错误)。这个变量每 0.5秒 增加 64000，并每隔 9.5 小时又回到 0 (对应这个计数器每 8ms 加 1，而不是 4ms 加 1)。另外，每建立一次连接后，这个变量将增加 64000。

### 建立连接超时

很多情况导致无法建立连接，一种情况是服务器主机没有处于正常状态。这时，客户端会重传 SYN 报文段，第 2 个 SYN 与 第 1 个的时间间隔为 5.5 ~ 6 秒，第 3 个与第 2 个的间隔是 24 秒。大多数 Berkeley 系统将建立一个新连接的最长时间限制在 75 秒以内，也就是说，请求端将在第 3 个 SYN 报文段发出后大约 45 秒放弃连接。

为什么第一次超时时间为 5.5 ~ 6 秒，这是因为 BSD 版的 TCP 软件采用一种 500 ms 的定时器，建立一个 6 秒的定时器 (12 个时钟滴答(tick))，滴答计数器可能在 0 ~ 500 ms (第一个时钟滴答) 中的任意时刻减 1。 当滴答计数器为 0 时，6秒的定时器便会超时，这个定时器会在 24 秒 (48 个时钟滴答) 重新复位，所以第二次的超时时间将会更接近 24 秒。

### 最大报文长度 (MSS)

最大报文长度 (MSS, Maximum Segment Size) 表示 TCP 传往另一端的的最大数据块的长度。在建立一个 TCP 连接时，每一方通常都在第一个报文段 (SYN 报文段) 中指明这个选项。

### TCP 的半连接

三次握手中，主动发起握手的一方不发最后一次 ACK，使得服务器端阻塞在 SYN_RECD 状态。当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

SYN 洪水攻击 (SYN Flood Attack) 就是利用了 TCP 的半连接状态。

### SYN 洪水攻击

SYN 洪水攻击 (SYN Flood Attack) 是当前最流行的拒绝服务攻击 (DOS, Denial Of Service) 和分布式拒绝服务攻击 (DDOS, Distributed Denial Of Service)，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，使被攻击方资源耗尽 (CPU 满负荷或内存不足) 的攻击方式。

**具体原理是：**

在 TCP 连接的三次握手中，请求端不发最后一次 ACK，使得服务器端阻塞在半连接状态 (SYN_RECD)，这将占用服务器的 CPU 和 内存资源。

在收到请求端的 SYN 段时，服务器会先分配 TCB (Transmission Contrl Block)，通常一个 TCB 至少需要 280 字节，有些操作系统甚至需要 1300 字节。并且 TCP 服务器会进行超时重传 SYN + ACK 段，然后等待一段时间后丢弃这个未完成的连接，一般来说这个时间是分钟级的 (大约为 30 秒到 2 分钟)。

如果恶意攻击者大量模拟这种情况，那么服务端将会维护一个非常大的半连接队列而消耗非常多的内存资源，还要不断对这个队列进行 SYN + ACK 的重传，这将消耗非常多的 CPU 资源。

如果服务器的 TCP/IP 栈不够健壮，那么最后的结果是堆栈溢出崩溃。即使服务器的系统足够健壮，服务器也将忙于处理攻击者伪造的 TCP 连接请求而顾不上客户的正常请求。此时，从正常客户的角度看来，服务器失去响应。

**防止 SYN 攻击的方案有:**

* 缩短 SYN 确认超时时间

* 记录 IP，若连续受到某个 IP 的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。

* 无效连接的监视释放  

监视系统的半连接和不活动连接，当达到一定阈值时释放这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于 SYN Flood 造成的半连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的防止 SYN Flood 方法。

* 延缓 TCB 分配方法  

消耗服务器内存资源主要是因为当 SYN 数据报文一到达，系统立即分配 TCB，从而占用了资源。而 SYN Flood 由于很难建立起正常连接，因此，当正常连接建立起来后再分配 TCB 则可以有效地减轻服务器资源的消耗。常见的方法是使用 SYN Cache 和 SYN Cookie 技术。

SYN Cache 技术是在系统收到一个 SYN 报文时，用一个 hash 表保存这种半连接信息（包括序列号），直到收到正确的 ACK 报文再分配 TCB，这个开销远小于 TCB 的开销。  

SYN Cookie 技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成 Sequence Number，这种算法考虑到了对方的IP、Port、己方IP、Port 的固定信息，以及对方无法知道而己方比较固定的一些信息，如 MSS、MSL 等，在收到对方的 ACK 报文后，重新计算一遍，看其是否与对方回应报文中的 (Sequence Number - 1) 相同，从而决定是否分配 TCB 资源。

* 使用 SYN Proxy 防火墙  

一种方式是防火墙确认连接的有效性后，防火墙才会向内部服务器发起 SYN 请求。防火墙代服务器发出的 SYN ACK 包使用的序列号为 s, 而真正的服务器回应的序列号为 s', 这样，在每个数据报文经过防火墙的时候进行序列号的修改。

另一种方式是防火墙确定了连接的安全后，会发出一个 safe reset 命令，client 会进行重新连接，这时出现的 SYN 报文会直接放行。这样不需要修改序列号了。但是，client 需要发起两次握手过程，因此建立连接的时间将会延长。

## TCP 终止连接

TCP 终止连接过程中首先进行关闭的一方称为将执行主动关闭，而另一方执行被动关闭。

TCP 终止连接需要四次挥手，这是因为当被动关闭方收到主动关闭方的 FIN 数据包后，被动关闭方可能还有数据没有发完，不能立即 close。所以被动关闭方先发送 ACK 确认主动关闭方的 FIN。然后发送剩下的数据，发完之后再发送 FIN 包给主动关闭方，表示发送完毕。然后主动关闭方发送 ACK 终止连接。

### 四次挥手

```txt
      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT

  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK

  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED

  6.  (2 MSL)
      CLOSED

                         Normal Close Sequence
```

1) 第 1 次挥手，主动关闭方发送一个 FIN，用来关闭主动关闭方到被动关闭方的数据传输，主动关闭方进入 FIN_WAIT_1 状态，等待被动关闭方的确认。

2) 第 2 次挥手，当被动关闭方收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。被动关闭方进入 CLOSE_WAIT 状态。和 SYN 一样，一个 FIN 将占用一个序号。主动关闭方收到 ACK 进入 FIN_WAIT_2 状态。TCP 协议栈为 FIN 包插入到文件结束符 EOF 缓冲区，应用程序通过调用 read 函数感应 FIN 包。

3) 第 3 次挥手，被动关闭方读到 EOF，应用程序调用 close 函数关闭它的套接字，导致被动关闭方发送一个 FIN，被动关闭方进入 LAST_ACK 状态。

4) 第 4 次挥手，主动关闭方收到 FIN，发回一个 ACK，确认序号为收到序号加 1。主动关闭方进入 TIME_WAIT 状态。

### 同时关闭

```txt
      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                  <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                  ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->

  3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                  ... <SEQ=101><ACK=301><CTL=ACK>      -->

  4.  TIME-WAIT                                            TIME-WAIT
      (2 MSL)                                              (2 MSL)
      CLOSED                                               CLOSED

                      Simultaneous Close Sequence
```

### TCP 的半关闭

TCP 提供了连接的一端在结束了它的发送后还能接收来自另一端数据的能力，这就是所谓的半关闭。

如果应用不调用 close 而调用 shutdown，且第二个参数为 SHUT_WR(1)，则 socket API 支持半关闭。

**半关闭的流程：**

1. 主动关闭方发送一个 FIN。

2. 被动关闭方收到 FIN 回应一个 ACK，并向应用进程交付 EOF。被动关闭方的应用进程调用 read 收到 EOF，此时被动关闭方还可以调用 write 向主动关闭方传输数据。

3. 被动关闭方数据传输完成后，发送一个 FIN。

4. 主动关闭方收到 FIN，发回一个 ACK。主动关闭方进入 TIME_WAIT 状态。

### TIME_WAIT 状态

TIME_WAIT 状态也称 2MSL 等待状态。每个具体的 TCP 实现必须选择一个报文段的最大生存时间 MSL(Maximum Segment Lifetime)。它是任何报文段在被丢弃前在网络内的最长时间。这个时间是有限的，因为 TCP 报文段以 IP 数据报在网络中传输，而 IP 数据报则是有限制其生存时间的 TTL 字段。

RFC 793 [Postel 1981c] 指出 MSL 为 2 分钟。然而，实现中的常用值是 30 秒，1 分钟，或 2 分钟。

对一个具体实现所给定的 MSL 值，处理的原则是：

1. 当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WATI 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防止这个 ACK 丢失(另一端超时并重发最后的 FIN)。

例如，如果主动关闭方发送最后的 ACK 在网络中丢失，这样被动关闭方收不到最后的 ACK。待重传定时器超时，被动关闭方将重传 FIN 到主动关闭方。如果没有 TIME_WAIT 状态，此时主动关闭方应该是 CLOSED 状态。收到重传的 FIN 后，它没有关于此 FIN 的任何信息，所以向被动关闭方发送一个 RST 报文段，被动关闭方收到 RST 后，认为连接出现了异常，而非正常关闭。如果有 TIME_WAIT 状态，收到重传的 FIN 后，将回复一个 ACK 来确认被动关闭方发送 FIN。再进入 TIME_WAIT 状态，2MSL 过后，TCP 连接正常关闭。

是否只要主动关闭方在 TIME_WAIT 状态下停留 2MSL，4次握手就一定能正常完成呢？

不一定，如果被动关闭方重传的 FIN 报文段也在网络中丢失了，主动关闭方在 TIME_WAIT 状态等待 2MSL 没收到任何报文段，进入 CLOSED 状态，被动关闭方就不会收到最后的 ACK。四次握手就没有正常完成。

因此，在 TIME_WAIT 状态等待 2MSL，只是尽量保证正常的 TCP 连接终止序列。

2. 确保老的报文段在网络中消失，不会影响新建立的连接。

例如，主动关闭方发送的最后一个 ACK 由于网络延迟没有按时到达，但并没有超过 MLS 时间，导致被动关闭方重传了一个 FIN，在重传 FIN 后，延迟的 ACK 到达，被动关闭方进入 CLOSED 状态。如果没有 TIME_WAIT 状态，则上述连接已经不存在。现在考虑下面情况，由于上述的连接已经关闭，现在可以马上建立一个与上述 IP 和 Port 等信息相同的新连接。那么当上一个连接重传的 FIN 到达时，被新的连接所接受，这将导致连接被复位。

这种 2MSL 等待的另一个结果是这个 TCP 连接在 2MSL 等待期间，定义这个连接的 socket 不能再被使用。这个连接只能在 2MSL 结束后才能被使用。

某些实现的 API 提供了一种避开这个限制的方法。使用 socket API 时，可说明其中的 SO_REUSEADDR 选项。它将让调用者对处于 2MSL 等待的本地端口进行赋值，但 TCP 原则上避免使用仍处于 2MSL 连接中的端口。

### 平静时间 (Quiet Time)

如果处于 TIME_WAIT 状态的主机出现故障，假如它在 MSL 内重新启动，并使用故障前仍处于 TIME_WAIT 状态的插口对建立新的连接。那么故障前从这个连接发送的迟到报文段将会被错误的当作新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这样的情况。

为了防止这种情况，RFC 793 指出 TCP 在启动后的 MSL 秒内不能建立任何连接。这就称为平静时间(Quiet Time)。

### FIN_WAIT_2 状态

在 FIN_WAIT_2 状态我们已经发出了 FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则将等待另一端应用层意识到它已收到一个文件结束符说明，并向我们发送一个 FIN 来关闭另一方向上的连接。只有当另一端完成这个关闭，我们这端才会从 FIN_WAIT_2 进入 TIME_WAIT 状态。

这意味着我们这端可能永远保持这个状态。另一端也将处于 CLOSE_WAIT 状态，并一直保持这个状态直到应用层决定进行关闭。

许多伯克利实现采用如下方式来防止 FIN_WAIT_2 的无限等待。如果执行主动关闭的应用层将进行全关闭，而不是半关闭来说明它还想接收数据，就设置一个定时器。如果这个连接空闲 10 分钟 75 秒，TCP 将进入 CLOSED 状态。在实现代码的注释中确认这个实现代码违背协议的规范。

### 复位报文段 (RST)

一般来说，无论何时一个报文段发往基准的连接出现错误，TCP 都会发出一个复位报文段。

RST的应用：

* 到不存在的端口的连接请求

* 异常终止一个连接

* 检测半打开连接

### TCP 半打开 (Half-Open)

如果一方异常关闭(断网、断电、内核崩溃、机器故障)，而另一方不知情。就处于半打开状态，如果双方不进行通信，是无法发现问题的。可以引入心跳机制，以检测半打开状态，检测到了发送 RST 重新建立连接。

## Nagle 算法

Nagle 算法要求一个 TCP 连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其它的小分组。然而，TCP 收集这些小分组，并在确认到来时以一个分组的方式发出去。

该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发送的越快。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组。

RFC 声明 TCP 必须实现 Nagle 算法，但必须为应用提供一种方法来关闭该算法在某个连接上执行。关闭 Nagle 算法，socket API 可以使用 TCP_NODELAY 选项来关闭 Nagle 算法。

## 延时确认

通常 TCP 在接收到数据时并不立即发送 ACK。相反，它推迟发送，以便将 ACK 与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带 ACK）。绝大多数实现采用的时延为 200 ms，也就是说，TCP 将以最大 200 ms 的时延等待是否有数据一起发送。

发送 ACK 的实际时间并不都是 200 ms，这是因为 TCP 使用了一个 200 ms 的定时器，该定时器以相对于内核引导的的 200 ms 固定时间溢出。由于需要确认的数据是随机到达的，TCP 在内核的 200 ms 定时器的下一次溢出发出 ACK。这可能是 1 ~ 200 ms 中的任何一刻。

## TCP 流量控制

如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

### 窗口大小

TCP 首部中有一个 16 bit 的窗口大小字段，也就是说，每一个 TCP 报文段都会通告自己的窗口大小，TCP 的流量控制由连接的每一端通过通告窗口大小来提供。窗口大小是一个 16 bit 字段，因此窗口大小最大为 65535 字节。  

### 滑动窗口机制

TCP 连接的每一方有通告窗口和滑动窗口，接收的报文段中的窗口大小是对方通告它的接收缓冲区还能放多少字节的数据，滑动窗口大小不能超过对方的接收窗口大小。

发送端的使用滑动窗口机制实现流量控制。下图是 TCP 连接中的一方的发送缓冲区使用滑动窗口机制示意图，图中一个数代表一个字节的数据。

```txt
               |-             滑动窗口             -|
               +-----------------------------------+
1     2     3  |  4     5     6  |  7     8     9  |  10     11     12
               +-----------------------------------+
|-发送并被确认 -|-发送但,未被确认 -|-    能够发送    -|- 不能够发送，直至窗口移动 -->
```

滑动窗口的起始位置是发送并被确认的数据的下一个字节，当数据被发送和确认时，滑动窗口左边沿向右边沿滑动，称为窗口合拢。

当另一端的接收进程读取已经确认的数据并释放了 TCP 接收缓存时，窗口的右边沿向右滑动将允许发送更多的数据，称为窗口张开。

## TCP 拥塞控制

假设发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现网络拥塞，中间路由器就必须缓存分组，并有可能耗尽存储空间。这种方式严重降低了 TCP 连接的吞吐量。慢启动机制则可以有效地解决此问题。

### 慢启动算法

慢启动算法为发送方增加了拥塞窗口 (cwnd, congestion window)。当建立 TCP 连接时，拥塞窗口初始化为 1 个报文段 (即 MSS)。每收到一个 ACK，就增加一个报文段 (cwnd 以字节为单位，但慢启动以报文段大小为单位进行增加)。发送方取拥塞窗口和通告窗口的最小值作为滑动窗口的大小。

慢启动算法在每收到一个 ACK，就增加一个 MSS 大小，看起来是线性增长的，其实它是指数增长的。发送方开始时发送一个报文段，在一个 RTT 时间内收到对方的 ACK，此时拥塞窗口从 1 增加为 2，即可以发送 2 个报文段，在一个 RTT 时间内收到这 2 个报文段的 ACK 时，拥塞窗口就增加为 4。以此类推，下一个就是 8，所以慢启动算法是一种指数增长。

### 拥塞避免算法

拥塞避免算法要求每次收到一个 ACK 时将 cwnd 增加 1 / MSS，即每经过一个往返时间 RTT 拥塞窗口 cwnd 就增加 1 个 MSS，这是一种线性增长。

拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关。

### 慢启动 + 拥塞避免

拥塞避免算法和慢启动算法需要对每个连接维持两个变量，一个拥塞窗口 cwnd 和一个慢启动门限 ssthresh。算法的工作过程如下：

1. 对于一个给定的连接，初始化 cwnd 为 1 个报文段，ssthresh 为 65535 个字节。TCP 滑动窗口大小不能超过 cwnd 和通告窗口的大小。开始执行慢启动算法，直到拥塞发生。

2. 当拥塞发生时（超时或收到重复确认），ssthresh 被设置为当前窗口大小的一半（cwnd 和接收方通告窗口大小的最小值，但最少为 2 个报文段）。此外，如果是超时引起了拥塞，则 cwnd 被设置为 1 个报文段（执行慢启动算法）。

3. 当新的数据被对方确认时，就增加 cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果 cwnd 小于或等于 ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止，然后转为执行拥塞避免。

## 超时与重传

连续重传之间的时间差分别是 1.5、3、6、12、24、48 和 6 个 64 秒。第七个 64 秒后 TCP 发送方将放弃并发送 RST 报文段。首次重传与 RST 报文段的时间差约为 9 分钟。

### 快速重传和快速恢复

快重传算法要求在收到一个失序的报文段时， TCP 立即需要产生一个 ACK (一个重复的 ACK)，这个重复的 ACK 不应该被延迟。该重复的 ACK 的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。

如果一连串收到 3 个或 3 个以上的重复 ACK，就非常可能是一个报文段丢失了。于是就重传丢失的数据报文段，而无需等待超时定时器溢出，这就是快速重传算法。接下来执行的不是慢启动算法而是拥塞避免算法，这就是快速恢复算法。

在这种情况下没有执行慢启动的原因是由于收到重复的 ACK 不仅仅告诉我们一个分组丢失了。由于接收方只有在收到另一个报文段时才会产生重复的 ACK，而该报文段已经离开了网络并进入了接收方的缓存。也就是说，在收发两端之间仍然有流动的数据，而我们不想执行慢启动来突然减少数据流。

该算法的工作过程如下：

1. 当收到第 3 个重复的 ACK 时，将 ssthresh 设置为当前拥塞窗口 cwnd 的一半。重传丢失的报文段。设置 cwnd 为 ssthresh 加上 3 倍的报文段大小。

2. 每次收到另一个重复的 ACK 时，cwnd 增加 1 个报文段大小并发送 1 个分组（如果新的 cwnd 允许发送）。

3. 当下一个确认新数据的 ACK 到达时，设置 cwnd 为 ssthresh（在第1步中设置的值）。这个 ACK 应该是在进行重传后的一个往返时间内对步骤 1 中重传的确认。另外，这个 ACK 也应该是对丢失的分组和收到的第 1 个重复的 ACK 之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。

## 坚持定时器

如果 TCP 连接的一方的通告窗口从 0 变为大于 0 时，将会发送一个 ACK 来通告窗口大小。如果这个 ACK 丢失，则 TCP 连接可能陷入死锁，接收方等待接收数据（因为它已经向发送方通告了一个非 0 的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer) 来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查  (window probe)。

发出窗口探查报文段的时间间隔是 5、5、6、12、24、48、60 秒，窗口探查与超时重传的区别是，窗口探查不会放弃，因为窗口探查报文会收到对方的 ACK 报文段通告最新窗口大小。

## 糊涂窗口综合征

糊涂窗口综合症是指当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会使应用进程间传送的报文段很小，特别是有效载荷很小；极端情况下，有效载荷可能只有 1 个字节；传输开销有 40 字节 (20 字节的 IP 头 + 20 字节的 TCP 头) 这种现象。糊涂窗口综合征可发生在 TCP 连接的两端，接收方可以通告一个小的窗口，而发送方也可以发送少量的数据。

接收方的解决方案是不通告小窗口，除非窗口可以增加一个报文段大小 (MSS) 或者可以增加接收方缓存空间的一半，不论实际有多少。

发送方解决方案是 Nagle 算法，并且只要以下条件之一满足时就发送数据：

1. 可以发送一个满长度的报文段。

2. 可以发送至少是接收方通告窗口大小一半的报文段。

3. 发送端没有还未被确认的数据或者该连接上不能使用 Nagle 算法。

## 保活定时器 (KeepAlive)

如果 TCP 连接的双方都没有向对方发送数据，那么这个 TCP 连接将一直保持建立。此时如果其中一方主机崩溃，正常运行的一方就无法得知对方主机已崩溃，从而导致浪费资源。

RFC 提到一个实现可提供保活的功能，但是除非应用程序指明要这样，否则就不能使用该功能。而且，保活间隔必须是可配置的，但是其默认值必须不小于两个小时。

如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段，服务器将会得到以下响应：

1. 客户机正常运行，并且服务器可达。服务器将重置保活定时器。

2. 客户机已经崩溃关机或者正在重启。服务器将会发送 10 个探查报文段，每个间隔 75 秒，之后就会认为客户机已经关闭并终止连接。

3. 客户机崩溃并已经重启。服务器将收到 RST 报文段，使得服务器终止这个连接。

4. 客户机正常，但服务器不可达（例如中间路由器崩溃）。这与第 2 条相同，因为 TCP 不能区分这两种情况。

保活定时器的缺点：

1. 在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉。

2. 它们耗费不必要的带宽。

3. 在按分组计费的情况下会在互联网上花掉更多的钱。

4. keepalive 只能检测连接是否存活，不能检测连接是否可用。例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层 keepalive 包。

5. TCP keepalive 机制依赖于操作系统的实现,灵活性不够，默认关闭，且默认的 keepalive 心跳时间是两个小时, 时间较长。

6. 代理服务器 (proxy server)、或者负载均衡器，会让 TCP keep-alive 失效