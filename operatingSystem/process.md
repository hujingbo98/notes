<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-12
-->

# 进程

为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，引入了进程 (Process) 的概念。

进程是资源分配的基本单位。一个进程由程序段、数据段和进程控制块三部分构成。

为了能使并发执行的每个程序 (含数据) 都能够独立的运行，操作系统为每个进程配置了一个专门的数据结构，称为进程控制块 (PCB, Process Control Block)。系统利用 PCB 来描述进程的基本情况和活动过程，进而控制和管理进程。

## 进程控制块

为了便于系统描述和管理进程的运行，在 OS 的核心为每个进程专门定义了一个数据结构 -- 进程控制块 (Process Control Block, PCB)。

PCB 的作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。

### PCB 的作用

PCB 一般有以下 5 个作用：

(1) 作为独立运行基本单位的标志。当系统创建一个新进程时，就会为他建立一个 PCB。进程结束时又回收其 PCB，进程也就随之消亡。系统是通过 PCB 感知进程的存在的。事实上，PCB 已成为进程存在于系统的的唯一标志。

(2) 能实现间断性的运行方式。在多道程序环境下，程序是采用停停走走间断性的运行方式运行的。当进程暂停运行时，它必须保存自己运行时的 CPU 现场信息，再次被调度运行时，需要恢复其  CPU 现场信息。OS 将现场信息保存在 PCB 中，以供再次被调度时恢复。

(3) 提供进程管理所需要的信息。操作系统总是根据 PCB 实施对进程的控制和管理。

(4) 提供进程调度所需要的信息。PCB 中提供了进程处于何种状态的信息，如果进程处于就绪状态，系统便将它插入到进程的就绪队列，等待调度程序调度。另外在进程调度时需要了解进程的其它信息，如在优先级调度算法中，就需要知道进程的优先级。

(5) 实现与其它进程的同步和通信。进程的同步机制是用于实现多进程的协调运行的，在采用信号量机制时，它要求在每个进程中都设置有相应的用于同步的信号量。在 PCB 中还具有实现进程通信的区域或通信队列指针。

### PCB 的结构

1. 进程标识符。在进程控制块中，唯一地标识一个进程。一个进程通常有两种标识符：

(1) 外部标识符，为了方便用户对进程的访问，必须为每一个进程设置一个外部标识符。它是有创建者提供的，通常由字母、数字组成。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。

(2) 内部标识符，为了方便系统对进程的使用，在 OS 中又为进程设置了内部标识符，即赋予每一个进程一个唯一地数字标识符，它通常是一个进程的序号。

2. 处理机状态。处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器包括：

(1) 通用寄存器，又称用户可视寄存器，它们是用户程序可以访问的，用于暂存信息；

(2) 指令计数器，其中存放了要访问的下一条指令的地址；

(3) 程序状态字 PSW，其中含有状态孽畜，如条件码、执行方式、中断屏蔽标志等；

(4) 用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。

当进程被切换时，处理机状态信息必须保存在相应的 PCB 中，以便在该进程重新执行时能再从断点继续执行。

3. 进程调度信息，在 OS 进行调度时，必须了解进程的状态及有关进程调度的信息，这些信息包括:

(1) 进程状态，指明进程的当前状态；

(2) 进程优先级；

(3) 进程调度时所需的其他信息，它与采用的进程调度算法有关，比如，进程已等待 CPU 的时间总和、进程已执行的时间总和等；

(4) 事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。

4. 进程控制信息，指用于进程控制所必须的信息，它包括：

(1) 程序和数据的地址，进程中的程序和数据的内存或外存地址，以便再调度到该进程执行时，能从 PCB 中找到其程序和数据；

(2) 进程同步和通信机制，这是实现进程同步和进程通信时必要的机制，如消息队列指针、信号量等，它们可能全部或部分地放在 PCB 中；

(3) 资源清单，在该清单中列出了进程在运行期间所需的全部资源 (除 CPU 以外)，另外还有一张已分配到该进程的资源的清单；

(4) 链接指针，它给出了本进程所在队列中的下一个进程的 PCB 的首地址。

### PCB 的组织方式

在一个系统中，通常可拥有多个 PCB。为了能对它们加以有效的管理，应该用合适的方式将这些 PCB 组织起来。目前常用的组织方式有以下三种：

(1) 线性方式，即将系统中所有 PCB 都组织在一张线性表中。该方式实现简单、开销小，但每次查找是需要扫描整张表，因此很少用。

(2) 链接方式，即把具有相同状态进程的 PCB 分别通过 PCB 中的链接字链接成一个队列。这样就可以形成就绪队列、若干阻塞队列和空白队列等。对就绪队列而言，往往按进程的优先级将 PCB 从高到低进行排列。

(3) 索引方式，即系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等。

Linux 的 PCB 组织方式是链表加哈希表，链表是用于将不同状态的进程加以划分，哈希表则是方便内核快速根据 PID 等键值查找对应的 PCB。

## 进程的状态

### 进程的三种基本状态

由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。一般而言，每一个进程至少应处于一下三种基本状态之一。

(1) 就绪 (Ready) 状态，是指进程已处于准备好运行的状态，即进程已分配到除 CPU 以外的所有必要资源后，只要再获取 CPU，便可立即执行。

(2) 执行 (Running) 状态，执行状态是指已获得 CPU，其程序正在执行的状态。

(3) 阻塞 (Block) 状态，阻塞状态是指正在执行的进程由于发生某事件 (如 I/O 请求、申请缓冲区失败等) 暂时无法继续执行的状态，即进程的执行受到阻塞

### 进程的三种基本状态的转换

进程在运行过程中经常发生状态的转换。

处于就绪状态的进程，在调度程序为之分配了 CPU 之后便可执行，相应的，其状态就由就绪态转换为执行态。

处于执行态的进程，如果分配给它的时间片已完而被剥夺 CPU 暂停执行时，其状态就由执行态转换为就绪态；如果因发生某事件，致使当前进程受阻，其状态就由执行态转换为阻塞态。

处于阻塞态的进程，因阻塞事件完成 (如 I/O 请求完成)，其状态就由阻塞态转换为就绪态。

### 进程的创建状态和终止状态

为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了创建状态和终止状态。

创建一个进程是一个复杂的过程，也有可能临时创建失败，如资源得不到满足等情况，此时，进程创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。

同理，进程的终止也是一个过程，进程终止时的状态称为终止状态。

### 进程的挂起操作

为了系统和用户观察和分析进程需要，引入了一个进程的挂起操作。当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。如原本处于就绪状态，则该进程将暂不接受调度。与挂起操作对应的操作是激活操作。

一般有以下几个原因引起进程挂起：

1. 终端用户需要。

2. 父进程请求，如修改子进程或协调子进程间的活动。

3. 操作系统需要，如系统工作超负荷，为了保证系统能正常运行，系统把一些不重要的进程挂起。还有系统有时希望挂起某些进程，以便检查运行中的资源使用情况进行记账等。

## 进程控制

### 进程的创建

#### 进程的创建过程

1. 申请空白 PCB，为新进程申请唯一的数字标识符，并从 PCB 集合中索取一个空白 PCB。

2. 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O 设备和 CPU 时间等。

3. 初始化进程控制块 (PCB)。PCB 的初始化包括：(1) 初始化标识信息；(2) 初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶；(3) 初始化处理机控制信息，将进程状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级要求。

4. 插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。

#### 创建进程的场景

1. 系统启动时，主要会初始化创建 3 个系统进程，一个 idle 空闲进程 (PID = 0)、一个 init 进程 (PID = 1)、一个页面守护进程 (PID = 2)。

2. 正在运行的进程执行系统调用创建一个子进程。

3. 用户请求创建一个新进程，如在 shell 中输出执行命令。

4. 提交一个批处理请求，会创建一个新进程来运行。

### 进程的终止

#### 引起进程终止的原因

1. 正常结束

2. 异常结束

3. 外界干预

### 子进程

子进程指的是由另一进程（对应称之为父进程）所创建的进程。子进程继承了对应的父进程的大部分属性，如文件描述符。

Linux 系统中，子进程创建不会立即复制父进程的所有资源，而是以只读的方式共享大部分父进程的资源，当需要修改地址空间资源时，触发只读保护，这时才会复制一份地址空间。这种机制叫是写时复制 (copy-on-write)。这种优化可以避免复制大量根本不会执行写操作的数据。

### 僵尸进程和孤儿进程

如果子进程退出后，它占用的进程描述符等资源没有被释放，只有等它父亲调用 wait() 或 waitpid() 获取到子进程的信息后，父进程会将子进程的资源释放。如果子进程的资源由于某种原因一直得不到释放，那么就一直处于僵尸状态，被称为僵尸进程。

当父进程先退出，子进程还在运行时，该子进程被称为孤儿进程。孤儿进程只是暂时的，系统会在父进程退出时启动寻父机制，首先在进程组中寻找，如果找不到就返回 init (pid = 1) 的进程作为父进程。

系统中如果驻留大量的僵尸进程会一直占用系统资源，解决的直接办法是杀死父进程，让它们变成孤儿进程，最后会被新的进程领养，新的父进程会例行检查子进程状态，释放僵尸进程的资源。

### 守护进程

守护进程 (daemon) 是生存期长的一种进程，它们常常在系统引导装入时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以说它们是在后台运行的。UNIX 系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾。例如，syslogd 就是指管理系统日志的守护进程。

#### 守护进程的创建

1. 调用 umask 将文件模式创建屏蔽字设置为一个已知值 (通常是 0)。

2. 调用 fork 创建子进程，然后调用 exit 使父进程退出。这样做实现了下面几点：(1) 父进程退出，将子进程变为孤儿进程，被领养，后在后台运行；(2) 虽然子进程继承了父进程的进程组 ID，但获得了一个新的进程 ID，这就保证了子进程不是一个进程组的组长。这是下一步 setsid 调用的先决条件。

3. 调用 setsid 创建一个新会话。这样做使调用进程：(1) 成为新会话的首进程；(2) 成为一个新进程组的组长进程；(c) 没有控制终端。

4. 将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载，否则会影响守护进程。

5. 关闭不在需要的文件描述符。这使守护进程不在持有从其父进程继承来的任何描述符。

6. 某些守护进程打开 /dev/null 使其具有文件描述符 0、1 和 2，这样，任何一个试图读标准输入，写标准输出或标准错误的库例程都不会产生任何效果。