<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

## 处理器调度

### 死锁

定义：多个并发执行的程序，由于资源竞争或推进顺序不当导致无法继续推进的现象叫死锁。

## 进程上下文切换

上下文切换指的是当前任务的资源（寄存器和程序计数器等）、状态等内容保存起来，然后加载新任务的资源和状态，跳转到新的程序计数器指定的指令继续执行。

进程上下文切换不仅需要保存虚拟内存、全局变量、文件描述符等用户空间资源，还需要保存内核堆栈、寄存器、程序计数器等内核资源。

线程上下文切换只需要保存自己的线程栈和寄存器内容，比进程切换开销小很多。

## 进程的调度算法

**批处理系统：**

1. 先来先服务 (FCFS, first-come first-served) 调度算法

FCFS 是最简单的调度算法。按照请求顺序进行调度，每次调度是从就绪进程队列中选择一个最先进入该队列的进程，为其分配 CPU。该进程一直运行到完成或发生某事件而阻塞后，进程调度程序才将 CPU 分配给其它进程。

FCFS 对短作业不利，因为短作业很快执行完成，长作业可以很快得到调度，但长作业会阻塞会面的短作业。

2. 短作业优先 (SJF, short job first) 调度算法

SJF 是以作业的长短来计算优先级，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的。

短作业优先的缺点有：

(1) 必须预知作业的运行时间。

(2) 对长作业非常不利

(3) 人-机无法实现交互

(4) 完全未考虑作业的紧迫程度

3. 优先级调度算法

4. 高响应比优先调度算法

**交互式系统：**

1. 时间片轮转调度算法

2. 优先级调度算法

3. 多队列调度算法

4. 多级反馈调度算法

**实时系统：**

1. 最早截止时间优先算法

2. 最低松弛度优先算法

3. 优先级倒置算法

与用户的交互性较强，需要保证较短的响应时间，满足用户的期望，主要有以下调度算法：

时间片轮转调度：CPU 时间划分为均等的时间片段，每个片段分配给不同的进程，当一个进程的时间片用完之后就切换到下一个进程执行，依次循环。这种方式可以使所有的进程得到公平调度，但是会造成频繁的进程上下文切换，增大系统开销。
优先级调度：每个进程定义一个优先级，重要的进程执行较长时间，次要的进程执行较短的时间。进程的优先级可以由系统动态的设定，可以为调度带来较大的灵活性
多级队列：设立多个优先级类的队列，未执行完时间片的进程放入到下一级队列中。比如第一级运行 1 个时间片，第二级运行 2 个时间片，第三级运行 4 个时间片，依次类推。假如一个需要运行 100 个时间片的进程，如果通过一般的时间片轮转，那么需要 100 次调度才能执行完，而多级队列只需要 1 + 2 + 4 + 8 + 16 + 32 + 37(64 中的 37 个) = 100，总共只需要 7 次调度就完成了。
多级队列也可以保证短的交互进程得到优先调度，随着当前进程优先级的不断降低，当有短的进程达到高优先级的队列时，当前进程会让出 CPU 让高优先级的进程先执行。
实时系统：

实时分为软实时和硬实时。前者可以容忍一定时间的延迟，而后者需要满足绝对的截止时间。

实时系统的调度算法分为静态和动态的，静态的调度需要提前知道进程所需运行的时间等信息，从而做出调度决策；而动态的调度算法不需要这些限制，而是在运行过程中进行调度决策。

实时系统的调度算法可以选择优先级调度，也可以使用多级队列，最短进程优先等调度算法。