<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-12-06
-->

# 分布式

### 如何生成全局唯一的 ID？有哪些方案？如何优化？

分布式唯一 ID 的特性和要求：

1. 全局唯一性：不能出现重复的 ID 号。

2. 趋势递增：在 Mysql InooDB 引擎中使用的是聚簇索引，多数 RDBMS 使用 B-Tree 来存储索引数据，在主键的选择上，应尽量使用有序的主键保证写入性能。

3. 单调递增：保证下一个 ID 一定大于上一个 ID，例如事务版本号、排序等特殊需求。

4. 信息安全：如果 ID 是连续的，可能会暴露系统和业务信息，比如订单号，根据 ID 可以直接指导订单量。所以也要支持 ID 无规则生成。

上述要求可应对不同的场景，3 和 4 需求是互斥的，无法使用同一个方案实现。

除了对 ID 号码自身的要求，业务还对 ID 生成系统的可用性要求极高，如果 ID 生成系统瘫痪，整个系统的业务都无法执行，这将是一场灾难。

因此，ID 生成系统应该做到：

1. 平均延迟和 TP999 延迟尽可能低；

2. 可用性 5 个 9；

3. 高 QPS。

方法一：数据库自增

使用数据库的 ID 自增策略，如 MySQL 的 auto_increment 或 auto_increment_offset。

优点是：

* 简单，利用数据库系统的功能实现，成本小，天然有序。

* ID 单调自增，可以实现一些对 ID 有特殊要求的业务。

缺点是：

* 强依赖 DB，当 DB 异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。

* 并发性不好，ID 发号性能瓶颈限制在单台 MySQL 的读写性能。

ID 生成器中 MySQL 并发问题的优化方法：

部署多个机器，每个机器设置不同的初始值和相同的步长，这里的步长和机器个数相等。比如，部署 2 台机器，机器 1 和机器 2 的初始值分别是 1 和 2，步长都是 2，机器 1 生成的 ID 序列是 (1, 3, 5, 7, 9, ...)，机器 2 生成的 ID 序列是 (2, 4, 6, 8, 10, ...)。假设我们要部署 n 台机器，步长需设置为 n，每台的初始值依次为 0, 1, 2 , ..., N-1。

这种架构能够满足性能的需求，但有缺点：

1. 水平扩展比较困难。在设计是应根据扩容需求决定步长，然后可以增加其它标记位区分扩容。

2. ID 没有了单调递增的特性，只能趋势递增，对于不关心 ID 的单调递增的业务不是很重要，可以容忍。

3. 数据库压力还是很大，每次获取 ID 都得读写一次数据库，只能靠添加机器来提高性能。

使用批量缓存自增 ID，缓解数据库的读写压力：

每次批量生成一批 ID 给不同的机器去慢慢消费，这样数据库的压力也会减小到 n 分之一，且故障后可以坚持一段时间。缺点是服务器重启、单点故障会造成 ID 不连续，可以容忍。

优化到这里的优点：

* 可以很方便的线性扩展，性能完全能够支撑大多数业务场景。

* ID号码是趋势递增的 8 byte 的 64 bit 数字，满足数据库存储的主键要求。

* 容灾性高：系统内部有号段缓存，即使 DB 宕机，短时间内仍能正常对外提供服务。

缺点：

* ID 号码不够随机，能够泄露发号数量的信息，不太安全。

* TP999 数据会出现偶尔的尖刺。这是因为当号段使用完之后瓶颈还是会落在数据库的 I/O 上，如果数据库发生慢查询或网络发生抖动，就会导致整个系统的响应时间变慢。

* DB 宕机会造成整个系统不可用。

对于第 2 个缺点，可以使用双 buffer 优化：可以在缓存 ID 用完之前，提前去申请下一批 ID。

另外可以将数据库换成 Redis 来生成 ID：Redis 的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的。

方法二：UUID

UUID (Universally Unique IDentifier)是 ISO 提出的一个概念，是基于当前时间、计数器（counter）和硬件标识（通常为无线网卡的MAC地址）等数据计算生成的。它的标准型式包含 32 个 16 进制数字，以连字号分为 5 段，形式为 8-8-8-8-8 的 36 个字符。目前为止业界一共有 5 种方式生成 UUID，详情见 IETF 发布的 UUID 规范 <https://www.ietf.org/rfc/rfc4122.txt>。

优点：

* 本地生成，没有网络消耗，生成简单，没有高可用风险。

缺点：

* 不易于存储：UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。

* 信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。

* 无序：由于生成的 UUID 是无序的字符串，如果作为 MySQL 的主键索引，在 InnoDB 引擎下，插入数据会引起数据位置的频繁变动，严重影响性能。

方法三：SnowFlake 雪花算法

雪花算法是 Twitter 开源的 64 位整数组成分布式 ID，性能较高，并且在单机上递增。其 ID 组成部分为：

1. 1 bit 保留，其值始终是 0；

2. 41 bit 时间戳，精确到毫秒，总共可以容纳约 69 年的时间。

3. 10 bit workerID，一般表示工作机器的 ID，可以再将 workerID 分为两部分，高 5 位来表示数据中心 ID，低 5 位来表示工作节点 ID，最多可容纳 1024 个节点。

4. 12 bit 序号，每个节点每毫秒 0 开始不断累加，最多可以累加到 4095，一共可以产生 4096 个序号。

UidGenerator 是百度开源的分布式 ID 生成器，其基于雪花算法实现。

Leaf 是美团开源的分布式 ID 生成器，实现了全局唯一，趋势递增，不规则 ID 等功能，但需要依赖关系数据库、Zookeeper 等中间件。

## 负载均衡

### 随机、加权随机

随机负载均衡是指获取一个随机数，然后访问这个随机数对应的服务器。

### 轮询、加权轮询、平滑加权轮询

轮询算法是把请求轮流分配给服务器，从服务器 1 开始，直到服务器 n，然后重新开始循环。

轮询算法并没有考虑每台服务器的处理能力，在实际部署中，由于每台服务器的配置、安装的业务和应用等不同，其处理能力会不一样。

加权轮询算法在轮询算法的基础上可以根据服务器的不同能力，给每个服务器分配不同的权重，根据每个服务器的权重来进行轮询分配。比如：服务器 A、B、C 的权重分别是 1、2、3，那么来自用户的请求 1、2、3、4、5、6 将分别被分配到服务器 A、B、B、C、C、C。

加权轮询算法是轮流将每个服务器所能接受的请求集中分配，因此，在给某一台服务器分配请求时，其它服务器处于空闲状态，从而降低了整个服务器集群的利用率。

Nginx 实现了一种叫平滑加权轮询算法 (smooth weighted round-robin balancing)，它是在加权轮询算法的基础上，将请求平滑、分散的分配到各服务器上。

平滑加权轮询算法的实现原理是：

每个服务器有两个权重遍历：weight，配置文件中置顶的改服务器的权重，这个值是固定不变的；current_weight，服务器目前的权重，一开始为 0，之后会动态调整。每次当请求到来时，会遍历数组中的所有服务器。

对于每个服务器，让它的 current_weight 增加它的 weight，同时累加所有服务器的 weitht，保存为 total。然后将请求分配给服务器中 current_weight 最大的那一个，最后把该服务器的 current_weight 减去 total。

例子：

```txt
server a weight = 3;
server b weight = 2;
server c weight = 5;
```

init current_weight = {0, 0, 0};

请求序号|current_weight before selected|select peer|current_weight after selected
:-:|:-:|:-:|:-:
1|{3, 2, 5}|c|{3, 2, -5}
2|{6, 4, 0}|a|{-4, 4, 0}
3|{-1, 6, 5}|b|{-1, -4, 5}
4|{2, -2, 10}|c|{2, -2, 0}
5|{5, 0, 5}|a|{-5, 0, 5}
6|{-2, 2, 10}|c|{-2, 2, 0}
7|{1, 4, 5}|c|{1, 4, -5}
8|{4, 6, 0}|b|{4, -4, 0}
9|{7, -2, 5}|a|{-3, -2, 5}
10|{0, 0, 10}|c|{0, 0, 0}

10 个请求中，a、b、c 分别被选取了 3、2、5 次，符合它们的权重值。分布均匀，current_weight 有回到了初始值 {0, 0, 0}。

### 一致性哈希算法

简单哈希法是对缓存服务器数量进行取模，在扩容时，会影响所有服务器，大量缓存会失效，从而导致缓存穿透，严重会导致雪崩。

一致性哈希引入了哈希环，环上有 n 个槽，一般为 2^32-1。具体的哈希值，对环的大小取模，顺时针方向最近的节点就是对应服务器。所以，当增删节点时，只会影响它顺时针方向的第一个节点。另外可以添加虚拟节点使哈希更分散。

除了一致性哈希负载均衡，一致性哈希算法还解决了分布式缓存动态伸缩导致大量缓存失效的问题。

### 分布式节点的通讯方式？这五台服务器的例子是否需要分为主、从服务器？

### 介绍主服务器的备份机制

### 主服务器使用了一个 id，但未同步给其他从服务器，然后主服务器宕掉了，而从服务器可能相同的 id，如何解决？

### 如果主服务器提前发送通知，中间出现丢包，从服务器未收到，怎么解决？或者主服务器如何得知从服务器是否收到通知？可以用 SYN、ACK 交互的方式解决吗？

## TODO: zookeeper

## TODO: 云？

## TODO: docker？