<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-12-05
-->

[toc]

## redis 是什么？

redis (Remote Dictionary Server 远程字典服务) 是一个开源的、使用 c 语言编写的、支持网络、基于内存的 key-value 数据库，并提供多种语言 API。

## redis 与其它键值存储有什么不同？

redis 支持多种数据类型、原子操作、事务、消息队列、数据持久化等功能。

## redis 适用于哪些场景？

适用于缓存数据访问频繁的数据，从而减轻 Mysql 的查询压力，提高访问性能。还适用于使用 redis 的数据类型来进行业务开发。比如使用 redis 的原子自增实现分布式锁、使用 Sorted set 实现排行榜、使用Set 实现好友关系、使用 List 实现消息队列。

reids 不适用于数据量太大，数据访问频率非常低的业务，数据量太大会增加成本，访问频率低，将数据保存在内存中浪费资源。

## redis 内存占用多少？

64 位的实例：

* 一个空实例使用 ~ 3MB 的内存。
* 100 万个小键 -> 字符串值使用 ~ 85MB 的内存。
* 100 万个键 -> 哈希值，具有 5 个字段的对象，使用 ~ 160 MB 内存。

可以使用 redis-benchmark 程序生成随机数据集，然后使用 INFO memory 命令查看使用的空间。

64 位系统将使用比 32 位系统多得多的内存来存储相同的键，特别是当键和值都很小时。这是因为指针在 64 位系统中占用 8 个字节。但当然好处是你可以在 64 位系统中拥有大量内存，因此为了运行大型 Redis 服务器，或多或少需要 64 位系统。另一种方法是分片。

## 如果 redis 内存不足会发生什么？

redis 要么被 linux kernel 杀死，要么因错误而崩溃，要么开始变慢。通常服务器将开始交换空间，redis 开始性能下降，所以用户可能会注意到有问题。

redis 内部有保护机制，允许用户设置内存使用的最大限制，使用 maxmemory 配置文件中的选项来限制 redis 可以使用的内存。如果达到此限制，redis 将回复写入命令错误，或可以配置内存淘汰。

info 命令可以查看 redis 和 server 的使用信息。

## redis 为什么那么快？

1. 基于内存，数据存放在内存，内存的响应大约 100 纳秒，这是 redis qps 万亿级别的基础。

2. 采用单线程、避免了不必要的线程切换和竞争条件产生的消耗。

3. 非阻塞 IO，redis 采用 epoll 做为 I/O 多路复用，将 epoll 中的连接、读、写、关闭都转换为了事件，不在 I/O 上浪费时间。

## redis 为什么是单线程的？

因为 cpu 不是 redis 的瓶颈，redis 的瓶颈是内存和网络带宽。单线程也能保证不会有两条命令被同时执行，不会产生并发问题。

## 怎么保证缓存和数据库的一致性？

理论上来讲，只要设置了合理的过期时间，就能保证缓存和数据库的数据最终是一致的。如果对实时一致性要求严格，就需要实现一些措施来保证实时一致性。

用户的增删改请求，我们需要数据库更新，对缓存可以进行更新也可以删除，因为删除后下次请求就会将数据刷到缓存中。

1. 如果先更新数据库，后更新缓存，那么并发更新数据库的情况下，会将脏数据刷到缓存。

2. 如果先更新缓存，后更新数据库，如果数据库更新失败，则会造成数据不一致。

3. 如果先删除缓存，后更新数据库。

如果连续来了两个请求，一个写请求 A 和一个查请求 B，会出现下列问题：

```txt
1. 请求 A 删除缓存。
2. 请求 B 发现缓存不存在，去数据库查询得到旧值，并刷入到缓存。
3. 请求 A 更新数据库。
```

可以采用延时双删除策略，先删除缓存，再更新数据库，再删除缓存，如果第二次删除缓存失败，则只能放到消息队列里做一个补偿。

```txt
1. 请求 A 删除缓存，主数据库更新。
2. 请求 B 发现缓存不存在，去从数据库查询得到旧值，并刷入到缓存。
3. 从数据库更新。
```

此时可强制 redis 填充数据的查询数据库操作都去主数据库查询。

另外可以将更新和读取操作进行异步串行化，也就是说，当数据有写时，不允许读。

4. 先更新数据库，后删除缓存。

在更新数据库是，读到脏数据，比如来了两个请求，第一个是写请求，第二个是读请求，并发操作是，第一个写请求刚写完，还没来得及删除缓存，第二个读请求读到了数据。这种方式无法避免这个问题。

如果缓存删除失败，会导致脏数据直到过期。可以利用消息队列进行删除补偿，如果消息队列崩掉，还可以订阅 mysql 的 binlog 日志对缓存进行操作。

## redis 有几种数据类型？分别是什么？可以用来做什么？分别是怎么实现的？

redis 有 8 中数据类型，分别是 String、Hash、List、Set、Sorted Set、HyperLogLog、BitMap、Geo。

String 是 Redis 最基本的键值对类型，它会把单独的一个键和单独的一个值关联起来，被关联的值既可以是普通的文字数据，也可以是图片、视频、音频、压缩文件等二进制数据。

String 类型提供的操作命令有：SET 和 GET (为字符串键设置值和获取字符串键的值。可用于缓存 html 等数据，还可用于互斥锁)、GETSET (在获取旧值的同时为字符串键设置新值)、MSET 和 MGET (同时为多个字符串键设置值，或者同时获取多个字符串键的值，这两个命令可以减少网络通信次数)、STRLEN (获取字符串值的长度)、GETRANGE 和 SETRANGE (获取字符串值指定索引范围内的内容，或者对字符串值指定索引范围内的内容进行修改) 、APPEND (将一些内容追加到字符串值的末尾，可用于日志)、INCR、DECR、INCRBY、DECRBY、INCRBYFLOAT、DECRBYFLOAT (这些命令可以对字符串键存储的整数值或者浮点数值执行加法操作或减法操作，可用于实现 ID 生成器、计数器、限速器和读写锁等)。

Redis 的散列键会将一个键和一个散列表在数据库里关联起来，用户可以在散列表中为任意多个字段设置值。与字符串键一样，散列的字段和值既可以是文本数据，也可以是二进制数据。通过使用散列键，用户可以把关联的多项数据存储到一个散列里面，以便对这些数据进行管理，或者针对它们执行批量操作。

Hash 类型提供的操作命令有：HSET 和 HGET (为散列的一个或多个字段设置值和获取散列的一个字段的值，可以实现具有时效的登录会话 session)、HSETNX (只在字段不存在的情况下为它设置值)、HINCRBY 和 HINCRBYFLOAT (对字段的整数值和浮点数进行加法或减法操作，可将多个计数器关联到一个散列键上，便于管理)、HSTRLEN (获取字段的字节长度)、HEXISTS (检查字段是否存在)、HDEL (删除字段)、HLEN (获取散列包含的字段数量)、HMSET 和 HMGET (一次为多个字段设置值和一次获取多个字段的值)、HKEYS (获取所有字段)、HVALS (获取所有值)、HGETALL (获取所有字段和值)。

Hash 还可用于存储图数据，散列键为图的 name，字段为图的边，值为边的权重。

字符串优势是：有 SETRANGE、GETRANGE、APPEND 命令，而散列没有。字符串可以为不同字段设置不同的过期时间，散列只可以为散列键设置过期时间。

散列的优势是：只需一个键，就可以把多个字段和值存储到散列里面。所以使用hashes会更省内存和cpu，统计、持久化、查找等操作会受到键数量的影响。除了资源方面，散列还可以有效的组织相关的多项数据，使数据更容易理解、清晰。

字符串键和散列键的选择：

1. 如果需要为每个数据项单独设置过期时间，那么使用字符串键。
2. 如果程序需要对数据项执行诸如SETRANGE、GETRANGE或者APPEND等操作，那么优先考虑使用字符串键。当然，用户也可以选择把数据存储在散列中，然后将类似SETRANGE、GETRANGE这样的操作交给客户端执行。
3. 如果程序需要存储的数据项比较多，并且你希望尽可能地减少存储数据所需的内存，就应该优先考虑使用散列键。
4. 如果多个数据项在逻辑上属于同一组或者同一类，那么应该优先考虑使用散列键。

Redis 的列表 (List) 是一种线性的有序结构，可按照元素被推入列表中的顺序来存储元素，这些元素可以是文本数据，也可以是二进制数据，并且列表中的元素可以重复出现。

List 类型提供的操作命令有：LPUSH 和 RPUSH (将元素推入列表左端或右端)、LPUSHX 和 RPUSHX (只对已存在的列表执行推入操作)、LPOP 和 RPOP (弹出列表最左端或最右端的元素)、RPOPLPUSH (将列表最右端的元素弹出并推入到左端)、LLEN (获取列表的长度)、LINDEX (获取指定索引上的元素)、LRANGE (获取指定范围上的元素)、LSET (为指定索引设置新元素)、LINSERT (将元素插入列表)、LTRIM (修剪列表)、LREM (从列表中移出指定元素)、BLPOP 和 BRPOP (阻塞式左端弹出或右端弹出)、BRPOPLPUSH (阻塞式右端弹出并推入左端操作)。

List 可以实现数组、链表、栈、队列、分页、待办事项列表、带阻塞功能的消息队列。

Redis 的集合 (Set) 键可以将任意多个各不相同的元素存储到集合中，这些元素既可以是文本数据也可以是二进制数据。集合与列表的区别是集合只会存储非重复元素、并以无序的方式存储。因此当我们需要存储多个元素时，就可以考虑这些元素是否可以以无序的方式存储，并且是否不会出现重复，如果是，那么就可以使用集合来存储这些元素，从而有效地利用集合操作的效率优势。

Set 类型提供的操作命令有：SADD 和 SREM (将元素添加到集合和从集合中删除元素)、SMOVE (将元素从一个集合移动到另一个集合)、SMEMBERS (获取集合中的所有元素)、SCARD (获取集合包含的元素数量)、SISMEMBER (检查给定元素是否存在于集合)、SINTER 和 SINTERSTORE (对集合执行交集运算)、SUNION 和 SUNIONSTORE (对集合执行并集运算)、SDIFF 和 SDIFFSTORE (对集合执行差集运算)、SRANDMEMBER (随机获取集合中的元素)、SPOP (随机地从集合中移出指定数量的元素)

Set 类型可以实现唯一计数器、打标签、点赞、投票、社交关系、抽奖、共同关注与推荐关注、使用反向索引构建商品筛选器。

Redis 的有序集合 (Sorted Set) 同时具有有序和集合两种性质，这种数据结构中的每个元素都由一个成员和一个与成员相关联的分值组成，其中成员以字符串的方式存储，而分值则以64位双精度浮点数格式存储。

Sorted Set 类型提供的操作命令有：ZADD 和 ZREM (添加或更新成员，移除指定成员)、ZSCORE (获取成员的分值)、ZINCRBY (对成员的分值执行自增或自减操作)、ZCARD (获取有序集合的大小)、ZRANK 和 ZREVERANK (获取成员在有序集合中的排名)、ZRANGE 和 ZREVRRANGE (获取指定范围内的成员)、ZRANGEBYSCORE 和 ZREVRRANGBYSCORE (获取指定分值范围内的成员)、ZCOUNT (统计指定分值范围内的成员数量)、ZREMRANGEBYRANK (移除指定排名范围内的成员)、ZREMRANGEBYSCORE (移除指定分值范围内的成员)、ZUNIONSTORE 和 ZINTERSTORE (有序集合的并集运算和交集运算)、ZRANGEBYLEX 和 ZREVRRANGEBYLEX (返回指定字典序范围内的成员)、ZLEXCOUNT (统计位于字典序指定范围内的成员数量)、ZREMRANGEBYLEX (移除位于字典序指定范围内的成员)、ZPOPMAX 和 ZPOPMIN (弹出分值最高和最低的成员)、BZPOPMAX 和 BZPOPMIN (阻塞式最大或最小元素弹出操作)。

Sorted Set 类型可以实现排行榜、时间线、商品推荐、自动补全。

## TODO: Redis 的跳表？

## 单个 Redis 实例可以容纳的最大键数是多少？散列、列表、集合、排序集合中元素的最大数量是多少？

Redis 最多可以处理 2^32 个键，每个实例至少可以处理 2.5 亿个键。每个散列、列表、集合和排序集合可以容纳 2^32 个元素。换句话说，redis 的限制可能是系统中的可用内存。

## redis 哈希冲突怎么解决？

redis 采用开链法解决 hash 冲突。但是当链表过长就会导致查找性能变差，所以 redis 为了追求快，使用了两个全局哈希表。用于 rehash 操作，增加现有的哈希桶数量，减少哈希冲突。

开始默认使用 hash 表 1 保存键值对数据，hash 表 2 此刻没有分配空间。当数据越来越多触发 rehash 操作，则执行以下操作：

给 hash 表 2 分配更大的空间；将 hash 表 1 的数据重新映射拷贝到 hash 表 2 中；释放 hash 表 1 的空间。

将 hash 表 1 的数据重新映射到 hash 表 2 的过程中并不是一次性的，这样会造成 Redis 阻塞，无法提供服务。而是采用了渐进式 rehash，每次处理客户端请求的时候，先从 hash 表 1 中第一个索引开始，将这个位置的所有数据拷贝到 hash 表 2 中，就这样将 rehash 分散到多次请求过程中，避免耗时阻塞。

## redis 的缓存穿透？怎么解决？

缓存穿透是指查询一个不存在的数据，由于缓存不命中时需要去数据库查询，这将导致这个不存在的数据每次请求都要去数据库查询，造成响应迟钝。

解决办法：

1. 缓存空对象，如果查询结果不存在，我们仍然把这个空结果进行缓存，并设置一个较短的过期时间。

2. 使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个不存在的数据大概率会被 bitmap 拦截。

## 什么是缓存雪崩？怎么解决？

如果缓存集中在一个时间失效，所有的查询都落到数据库上，这就是缓存雪崩。

解决办法：

1. 均匀设置过期时间，或者设置永不过期，或者设置随机过期时间，让缓存失效的时间均匀点。

2. 加锁，对某个 key 只允许一个查询数据库请求。

3. 实现二级缓存或双缓存策略。

4. 数据预热，实现 reload 机制，预先去更新缓存。

## redis 过期键和删除策略？

定义过期

惰性过期

定期过期

## redis 的内存淘汰策略？

volatile-lru，从有过期时间的数据集中挑选最近最少使用的数据淘汰。

volatile-ttl，从有过期时间的数据集中挑选将要过期的数据。

volatile-random，从有过期时间的数据集中随机淘汰数据。

allkeys-lru，从数据集中挑选最近最少使用的数据淘汰。

allkeys-random，从数据集中随机淘汰。

no-enviction（驱逐）：禁止驱逐数据。

## redis 的事务？

## redis 持久化机制？

持久化就是把内存中的数据写到磁盘中，防止服务器宕机后内存数据丢失。reids 提供了两种持久化方式，RDB (默认) 和 AOF。

RDB 是 Redis Database 的缩写，按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘中，通过配置文件中的 save 参数来定义快照的周期。核心函数是 rdbSave (生成 RDB 文件) 和 rdbLoad (从 RDB 文件恢复) 两个函数。

AOF 是 Append-only file 的缩写。Redis 会将每一个收到的写命令追加到 aof 文件中，类似于 mysql 的 binlog，当 Redis 重启时，会通过重新执行文件中保存的写命令来在内存中重建整个缓存内容。

AOF 文件保存快，可高频保存，来保证数据不会丢失，但时间过长文件也会更大，并且恢复慢。RDB 每次都需要保存内存快照，保存速度较慢，但恢复很快。可以两个搭配使用。RDB 低频保存，AOF 高频保存，恢复先使用 RDB，后使用 AOF。

## redis 是如何生成 rdb 文件的？生成 rdb 期间，可以同时处理写请求吗？

可以的，redis 使用 fork 子进程来生成 rdb，采用操作系统 fork 的写时复制机制 (copy-on-write) 来避免内存的拷贝，所以可以同时处理写请求。

## 即使我有很多空闲 RAM，在 Linux 下后台保存也会因 fork() 错误而失败？

可以使用命令 `echo 1 > /proc/sys/vm/overcommit_memory` 来更改内核的分配内存策略。

overcommit_memory=0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。

overcommit_memory=1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。

overcommit_memory=2， 表示内核允许分配超过所有物理内存和交换空间总和的内存。
