<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

[toc]

# Linux

### shell 是什么？

shell 是命令解释器, 它的作用是对用户输入到终端的命令进行解析，调用对应的执行程序。

### 简单描述一下 linux 的目录结构

目录|解释
:-|:-
/bin|存放系统可执行文件，例如：ls、cd、cat 等
/sbin|存放 root 用户的系统可执行程序
/boot|存放内核和启动程序的相关文件
/lib|库目录，存放系统最基本的动态库
/meida|默认挂载设备媒体的目录，例如 U盘、光驱
/mnt|推荐挂载设备媒体的目录
/usr|用于存放庞大而复杂的目录 (unix system resource)，用于安装软件的目录
/proc|系统内存的映射 (随着系统的运行，时长变化的)
/etc|系统软件的启动和配置目录
/dev|用于存放设备文件
/home|家目录，所有用户的根目录 (当前用户的根目录是 /home/<user>)

### linux 下文件的类型有哪些？

- 普通文件，d 目录文件，c 字符设备文件，b 块设备文件，l 链接文件，p 管道文件，s 套接字

### 描述一下软连接和硬链接的区别？

软链接：ln -s <src_file> <dest_file>

硬链接：ln <src_file> <dest_file>

软链接可以理解成快捷方式，它和 windows 下的快捷方式的作用是一样的。

硬链接等于 cp -p 加同步更新。

### inode 是什么？

inode，中文译名为索引节点，每一个文件都有一个对应的 inode 保存文件的元数据，系统可以根据这些元数据，找到文件在硬盘中的存储位置。使用 stat 命令可以查看文件的 inode 信息。inode 保存了文件的字节数、uid、gid、rwx 权限、创建时间、上一次读取时间、上一次文件内容修改时间、上一次元数据修改时间

### Linux 的内存管理机制是什么？

虚拟内存可以利用磁盘空间虚拟出一块逻辑内存，用作虚拟内存的磁盘空间称为交换空间。也就是说，内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。

Linux 的内存管理采用分页存储机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。

Linux 和 Windows 内存管理的区别：

Linux 优先使用物理内存，当物理内存还有空闲时，Linux 是不会释放内存的，即使占用内存的程序已经被关闭了（这部分内存就用来做缓存了）。也就是说，即使你有很大的内存，用过一段时间后，也会被占满。这样做的好处是，启动那些刚开启过的程序、或是读取刚存取过得数据会比较快，对于服务器很有好处。

Windows 则总是给内存留下一定的空闲空间，即使内存有空闲也会让程序使用一些虚拟内存，这样做的好处是，启动新的程序比较快，直接分给它些空闲内存就可以了，而 Linux 下，由于内存经常处于全部被使用的状态，则要先清理出一块内存，再分配给新的程序使用，因此，新程序的启动会慢一些。

buffers 与 cached 都是内存操作，用来保存系统曾经打开过的文件以及文件属性信息，这样当操作系统需要读取某些文件时，会首先在 buffers 与 cached 内存区查找，如果找到，直接读出传送给应用程序，如果没有找到需要数据，才从磁盘读取，这就是操作系统的缓存机制，通过缓存，大大提高了操作系统的性能。buffers 与 cached 缓冲的内容却是不同的。buffers 是用来缓冲块设备做的，它只记录文件系统的元数据（metadata）以及 tracking in-flight pages，而 cached 是用来给文件做缓冲。也就是说，buffers 主要用来存放目录里面有什么内容，文件的属性以及权限等等。而 cached 直接用来记忆我们打开过的文件和程序。

物理地址和虚拟地址，它们之间通过 MMU 来做地址翻译，物理地址就是物理内存真正的地址；虚拟地址为每个进程提供了一个大的、一致的、私有的地址空间。

进程的内存空间的组织分布：

* 代码段，这是由 CPU 执行的机器指令部分。通常，代码段是可共享的，所以即使是频繁执行的程序在存储器中也只需要一个副本，另外，代码段常常是只读的，以防止程序由于意外而修改其指令。

* 初始化数据段，通常将此段称为数据段。它包含了程序中明确地赋非 0 初值的全局变量、静态变量。代码段不是只读的，在运行时变量的值是可以改变的。数据段还可细分为初始化只读区和初始化可读写区。

* 未初始化数据段，通常将此段称为 bss 段，这一名字来源于早期汇编程序一个操作符，意思是“由符号开始的块” (block started by symbol)。在程序开始执行之前，它包含了程序中初始化为 0 的和未初始化的全局变量、静态变量，内核将此段中的数据初始化为 0 或空指针。生命周期是整个进程的生命周期的变量都保存在数据段或 bss 段。

* 堆。通常在堆中进行动态内存分配，堆位于 bss 段末尾，并向高地址生长。

* 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中，栈与对是相邻的，并向对方的方向生长，因此栈的内存地址是从高到低分配的，当栈指针触及到堆指针位置时，意味着堆栈空间已被耗尽。

* 内存映射段。该段保存共享库和共享内存的映射。

### Linux 的任务调度机制是什么？

任务的调度是两个过程：上下文切换和调度算法。

上下文切换是从一个进程的上下文切换到另一个进程的上下文。

调度算法分为主动式调度和被动式调度。主动式调度随时都可以进行，在内核空间中，进程可以通过 schedule() 启动一次调度；在用户空间中，可以通过系统调用 pause() 达到同样的目的。如果要为自愿暂停行为加上时间限制，在内核中使用 schedule_time()，在用户空间使用 nanosleep() 系统调用。

被动式调度有：用户抢占和内核抢占。用户抢占发生在从系统调用返回用户空间，从中断处理返回用户空间。内核抢占一般发生在时间片用完或更高优先级进程抢占。

Linux 支持 SCHED_FIFO (先来先服务调度) 、 SCHED_RR（时间片轮转调度）和动态优先级调度。

### Linux PCB 是怎么实现的？

Linux 中 PCB 本质是一个结构体，里边的属性有：

进程 PID、用户 ID、用户组 ID、会话信息、所属终端信息、虚拟地址空间信息、文件描述符表、信号相关信息、当前工作目录、进程状态、CPU 寄存器。

### 文件描述符表是什么？

Linux 中每个进程都有一个文件描述符表，文件描述符表保存在 PCB 中，一个文件描述符表本质上是一个位图数组，可以使用 ulimit -n 查看最大文件描述符个数，默认是 65535。另外文件描述符的前三个 0、1、2 默认是打开的，分别是标准输入、标准输出和标准错误。

### Linux 创建子进程的写时复制？

Linux 在创建子进程时，不会立即复制父进程的数据，而是在写数据前，以页为单位将数据复制到子进程，然后在写入数据。

## 系统调用

### exit() 和 _exit()的区别是什么？

exit 会先调用出口函数，用户可以在程序终止时执行自己的清理动作；然后 exit 会关闭所有打开的描述符，这将导致刷新缓冲区；最后调用 _exit 函数终止进程。

## 命令

### top

top 命令的输出信息：

```txt
top - 00:23:09 up 75 days,  9:33,  0 users,  load average: 0.01, 0.06, 0.06
Tasks:  92 total,   1 running,  91 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.0 us,  2.0 sy,  0.0 ni, 96.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   1987.7 total,    477.0 free,    461.3 used,   1049.4 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1340.8 avail Mem 

PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND 
```

第一行是任务队列信息：

字段|解释
:-|:-
`00:23:09`|当前系统时间
`up 75 days,  9:33,`|表示系统已经运行了 75 天 9 小时 33 分钟
`0 users`|当前有 0 个用户登录系统
`load average: 0.01, 0.06, 0.06`|三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。

第二行是任务进程信息：

字段|解释
:-|:-
92 total|系统现在共有 92 个任务或线程
1 running|1 个处于运行态
91 sleeping|91 个在休眠
0 stopped|0 个正在跟踪或停止
0 zombie|0 个僵尸进程

第三行是 cpu 状态信息：

字段|解释
:-|:-
`2.0 us`|用户态占用 CPU 的百分比
`2.0 sy`|系统态占用 CPU 的百分比
`0.0 ni`|改变过优先级的进程占用 CPU 的百分比
`96.0 id`|空闲 CPU 百分比
`0.0 wa`|I/O 等待占用 CPU 的百分比
`0.0 hi`|硬中断占用 CPU 的百分比
`0.0 si`|软中断占用 CPU 的百分比
`0.0 st`|vm 等待 CPU 的百分比

第四行是内存状态信息：

字段|解释
:-|:-
`1987.7 total`|物理总内存量
`477.0 free`|空闲内存总量
`461.3 used`|使用中的内存总量
`1049.4 buff/cache`|缓存中的内存量

第五行是交换分区信息：

字段|解释
:-|:-
`0.0 total`|交换总量
`0.0 free`|空闲交换区总量
`0.0 used`|使用的交换区总量
`1340.8 avail Mem`|在不进行交换的情况下，估计可用的内存总量，考虑到页面置换的情况，一般比 free + buff/cache 少一点

下面是个进程的状态监控：

字段|解释
:-|:-
PID|进程 ID
USER|进程所有者
PR|进程优先级
NI|nice 值，负值表示高优先级，正值表示低优先级
VIRT|进程使用的虚拟内存总量，单位 kb，VIRT = SWAP + RES
RES|进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR|共享内存大小，单位 kb 
S|进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU|上次更新到现在的CPU时间占用百分比
%MEM|进程使用的物理内存百分比   
TIME+|进程使用的CPU时间总计，单位1/100秒 
COMMAND|进程名称（命令名/命令行）

### netstat

netstat：查看网络状态

* -a：显示所有 socket

* -n: 显示 IP 地址，而不通过域名服务器

* -u：显示 UDP

* -t：显示 TCP

* -l：显示 listen 状态下的服务器 socket

* -p：显示正在使用 socket 的进程号和进程名

### tcpdump

tcpdump：网络抓包工具

* -c：指定要抓包的数量

* -i：指定要抓包的接口，默认抓取第一个网络接口

* -n：对地址以数字的方式显示，否则显示为主机名，也就是说 -n 选项不做主机名解析

* -nn：除了 -n 的作用，还把端口显示为数值，否则显示端口服务名

* -P：指定要抓取的包是流入还是流出的包，可以给定 in、out 和 inout，默认是 inout

* -s：设置抓取数据报的长度，默认是 65535 字节

表达式：host、net、port、portrange、src、dst、src or dst、src and dst、tcp、udp、icmp

表达式操作符：and、&&、or、||、not、！

### ipcs

ipcs：显示系统消息队列、共享内存、信号等信息

* -l：查看系统消息队列、共享内存、信号的系统限制信息

* -u：查看系统消息队列、共享内存、信号的资源使用信息

### lsof

lsof：查看进程打开的文件，查看打开文件的进程，进程打开的端口等。

* -i：查看端口

### df

df：显示磁盘分区上可以使用的磁盘空间

* -a：查看全部文件系统，单位默认 KB

* -h：以 k、m、G 为单位显示，提高可读性。

### du

du：显示每个文件和目录的磁盘使用空间

* -s：显示目录的总和

* -h：以 k、m、G 为单位显示，提高可读性。

### free

free 命令：显示 Linux 系统中的空闲的、已用的物理内存及 swap 内存，以及 buff/cache。

### tail

tail：输出文件的后面部分

* -f：循环读取

* -n <行数>：显示文件尾部的 n 行内容

* -s：表示循环读取的间隔时间

### sed

sed：行数据处理命令，可以对行数据进行增删改查。

* -a：在行后新增一行数据。例：`nl /etc/passwd | sed '2a hello world'`：在第 2 行后新增一行数据，内容是 hello world

* -c：替换一行或多行数据。例：`nl /etc/passwd | sed '2,5c hello world'`：将第 2~5 行替换为 hello world

* -d：删除一行或多行数据。例：`nl /etc/passwd | 'sed 2,5d'`：删除第 2~5 行

* -i：在行前插入一行数据。例：`nl /etc/passwd | sed '2i hello world'`：在第 2 行前新增一行数据，内容是 hello world

* -p：只列出一行或多行数据。例：`nl /etc/passwd | sed '2,5p'`：只留底 2~5 行数据

* -s：在行内进行数据替换。例：`nl /etc/passwd | sed '2s/:/-/g'`：将第 2 行的所有 : 都替换为 -

* -i：直接修改文件内容，而不是修改输出信息。例：`sed -i '1i start' test.txt`，在 test.txt 文件首部添加一行，内容是 start

### awk

awk：字段列数据处理命令

* 例：`last -n 5 | awk '{print $1 "\t" $3}'`：列出第 1 列和第 3 列数据

* NF：当前行拥有的列数。例：`last -n 5 | awk '{printf $1 "\t column: " NF}'`

* NR：当前行是第几行数据。例：`last -n 5 | awk '{printf $1 "\t line: " NR}'`

* FS：设置列的分隔符，默认是空白字符。例：`cat /etc/passwd | awk 'BEGIN {FS=":"} {print $1 "\t" $3}'`

* 逻辑运算符：>、<、>=、<=、==、!=。例：`cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10  {print $1 "\t" $3}'`

## FQS & Solution

### top 命令中的 free 字段是实际的空闲内存？

不是的，已使用的内存有未使用的部分，因为 Linux 的 buff/cache 机制。

### linux取文件倒数十行用什么命令？

tail -n 10

### TODO: 两个文本文件里面，每一行都是一个整数，求在A文件里但不在B文件里的那些数字用shell脚本可以做吗？
