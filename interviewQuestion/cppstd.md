<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

[toc]

# C++ STD

### string 写时复制？

C++11 之前的标准没有规定 string 的实现方式，在 C++11 之前，大多数编译器为了提高性能，string 的实现都是写时复制。

写时复制一般采用引用计数来实现，会存在线程安全问题，多线程下的引用计数必须是原子操作。实现细节是：在复制字符串时，引用计数加 1；在写字符串时，如果引用计数大于 1，则先将引用计数减 1，然后复制出一个新的字符串。

C++11 标准规定：不允许 [] 导致之前的迭代器失效，这就使得写时复制的 string 不再符合 C++ 标准规范了。

C++11 之后的 string 采用实时拷贝加短字符优化，不同编译器的短字符优化不同。

GCC 中的短字符优化是：string 类中都会有一个 capacity 成员来保存已获取的堆区空间大小，当 string 长度小于等于 15 时，使用 capacity 成员的空间，capacity 是栈上的空间；当长度大于等于 15 时，在堆上分配空间。

### C++ 中的 string 类能否被继承？

std::string 不应该被继承，原因有两点：

1. std::string 中没有虚析构函数，也没有提供任何虚函数，因此继承了也不能实现多态。如果无需实现多态，就没有理由在 C++ 中使用继承，使用组合完全可以实现。

2. 在 C++ 中类是值类型，当一个函数接收 std::string 参数时，如果参数传入的是 std::string 的派生类对象，会出现切片问题，也就是说，函数内无法访问派生类的资源，这可能会导致调用成员函数获取到的字符串与原本的字符串不一致。

### vector 内存如何管理？

vector 底层是一个动态数组，默认大小为 0，在插入新元素时会自动扩容。自动扩容就是申请一片新的内存空间，把旧内存空间中的数据复制到新的内存空间，然后释放旧的内存空间。

在扩容时使用未雨绸缪机制，VS 中以原 vector 空间大小的 1.5 倍扩容，GCC 以 2 倍扩容。

### vector 中迭代器会失效吗？

vector 在 insert 时，只要引起空间的重新配置，旧的迭代器会全部失效。

在 erase 时，会将删除元素后面的所有元素向前移动，所以删除元素后边的迭代器也都会失效，但 erase 函数返回下一个元素的迭代器，所以可以在 erase 时接收其返回值来避免迭代器失效。

### vector 中，为什么 VS 使用 1.5 被扩容，GCC 使用 2 被扩容？

空间和时间的权衡吧，空间分配的多，扩容的次数小，时间复杂度就低。

另外 2 倍扩容的问题在于，每次扩容后的新尺寸必然刚好大于之前分配的总和，也就是说，即使之前分配的空间都是连续的，也不可能被使用，这样对内存不友好。

gcc 可能考虑到 vector 每次扩容所分配的内存都是连续的的概率很小，所以采用 2 倍扩容？？？

### vector 扩容会产生什么影响？怎么避免？

vector 频繁扩容会影响程序效率并会造成过多内存碎片，可以合理的使用 resize() 和 reserve() 方法避免 vector 自动扩容。

size() 返回已使用空间的大小，capacity() 返回总空间的大小，capacity() - size() 是未使用的空间大小。resize() 改变会改变 size() 和 capacity 的大小，reserve() 只会改变 capacity() 的大小。capacity() 的大小只增不减，如果想缩容的话，可以调用 shrink_to_fit() 将 capacity() 减少到 size()，这将会发生重新分配，所有的迭代器将失效。

### vector 扩容机制为什么不使用类似 c 的 realloc() 在尾元素后面的空间申请内存？

c++ 标准库容器的动态内存分配是交给分配器 Allocator 类处理的。对于默认分配器 std::allocator，有的版本实现是对 malloc/free 做了一层封装，但有的版本是自己做了内存池，可能不支持 realloc。如果是定制化的分配器，也可能不支持 realloc。

c 标准库的 realloc 有可能在原地扩容或缩容，有时也需要重新分配新内存空间，并且是直接按位浅拷贝的。对于 POD 类型这样用没问题，对于非 POD 类型这样做很危险。

vector 底层的原理是先用分配器分配出空间，然后有创建对象的需要时使用 placement new 显式调用构造函数。销毁对象时需要显式调用析构函数，最后在用分配器释放内存。简单理解就是如下：

```cpp
T * raw = (T*) malloc(sizeof(T) * N); // 分配内存
new (&raw[0]) T(); // 用 placement new 显式调用构造函数
raw[0].~T(); // 显式调用析构函数
free(raw); // 释放缓冲区
```

c++11 起 vector 扩容时是把 vector 中的元素移动构造过去。

### vector 删除元素后会释放空间吗？

vector 中的 erase 只能删除元素，不能改变总容量大小，vector 是不能缩容的，如果想要缩容，可以使用 deque 容器。另外可以调用 shrink_to_fit() 将 capacity() 减少到 size()，这将会发生重新分配，所有的迭代器将失效。

### vector 如果扩容原空间拷到新空间时有新元素插入会发生什么?

stl 中的所有修改操作都不是线程安全的，都不是原子性操作。如果多线程同时插入新元素，可能会导致未知错误。

### vector 通过下标访问？越界访问会怎样？

通过下标访问 vector 中的元素时，不会做边界检查，即使越界。如果想要边界检查，可以使用 at 函数。

### set

set 是有序唯一键集合容器，可以自定义 compare 函数进行排序，通常实现为红黑树，增删查的时间复杂度是 logn。

### map

map 是有序键值对集合容器，它的键是唯一的，可以自定义 compare 函数进行排序，通常实现为红黑树，增删查的时间复杂度是 logn。

### multiset

multiset 是有序键集合容器，它允许多个键重复，其它特性与 set 相同。

### multimap

multimap 是有序键值对集合容器，它允许多个键重复，其它特性与 map 相同。

### hash table

哈希表是通过哈希结果组织进桶，桶实际上就是一个大数组，然后采用开链法来解决哈希冲突，如果链表的元素大于 8 个，将会采用红黑树来提高性能。它的扩容条件是当桶个数 < 最大条目数/最大装载因子，MSVC 会扩容到满足条件的最小素数，GCC 是按 2 倍来扩容的，扩容后需要进行 rehash。

如果提前可以知道元素的数量，可以使用 reserve 来提前分配空间，将会避免 rehash。

hash table 的大小是素数时碰撞的概率小（有证明）。若直接扩大为两倍反而可能性能恶化。另外随着 size 变大，素数的密度会下降得足够小，也不至于反复扩容。<https://stackoverflow.com/questions/1145217/why-should-hash-functions-use-a-prime-number-modulus>

### unordered_set

unordered_set 是无序唯一键集合容器，通常实现为哈希表，增删查都是常数时间复杂度，元素在内部不排序，而是组织进桶。

### unordered_map

unordered_map 是无序键值对集合容器，它的键是唯一的，通常实现为哈希表，增删查都是常数时间复杂度，元素在内部不排序，而是组织进桶。

### unordered_multiset

unordered_multiset 是无序键集合容器，它允许多个键重复，其它特性与 unordered_set 相同。

### unordered_multimap

unordered_multimap 是无序键值对集合容器，它允许多个键重复，其它特性与 unordered_map 相同。

### STL 中红黑树实现的容器和哈希表实现的容器有什么区别？分别什么时候用？

set 和 unordered_set 都是集合，都不允许元素重复，set 底层使用 RB-Tree，自带排序功能，增删查的时间复杂度都是 O(logn)，unordered_set 底层使用哈希表，没有排序特性，增删查的时间复杂度都是常数级别的。这并不代表常数一定小于 logn，该常数取决于哈希函数和哈希冲突的处理。

红黑树自带排序功能，增删查的时间复杂度是 O(logn)。哈希表不带排序功能，增删查的时间复杂度是 O(1)。

在实际开发中，如果需要排序功能，则只能使用红黑树容器。

在数据量不大的情况下，红黑树的性能会优于哈希表，这是因为哈希表的哈希函数和 rehash 机制的耗时会大于红黑树的 logn。

在海量数据的情况下，红黑树的性能会差很多，这取决于红黑树的高度，如果是百万数据，红黑树的高度大概是二十多，此时哈希表的常数时间复杂度会更优。另外海量数据需要注意哈希表的 rehash 机制，如果提前可以知道元素的数量，可以使用 reserve 提前分配空间，避免 rehash。

空间方面，红黑树会多保存一些红黑属性和空节点，但不会重新分配空间。hashtable 底层采用数组保存，必然会有空间浪费，并且还有 rehash 机制。

### map 的插入方式有哪些？

1. 使用 insert 插入 pair 数据、make_pair 数据、value_type 数据。

2. 使用数组方式插入数据。

### map 的 find 与 [] 下标访问？访问下标越界？

map 的 find 函数使用 key 执行查找，存在返回迭代器，不存在返回尾迭代器。

下标访问时，会使用 key 执行查找，并返回相应的值，如果该 key 不存在，则会插入一个默认值。

### map 的 insert 和 [] = 有区别吗？哪个更好？

[]= 会产生临时对象，而 insert 不会。

### 容器删除一个元素，迭代器会失效吗？

顺序容器使用 erase 删除一个元素，不仅会使删除的迭代器失效，而且被删除元素之后的所有元素会往前移动，所以后面所有的迭代器都会失效，list 除外，所以不能使用 erase(it++) 的方式，但顺序容器的 erase 的返回值是下一个有效的迭代器。

关联容器使用 earse 删除一个元素，只是被删除元素的迭代器失效，erase 的返回值是 void，可以采用 earse(it++) 的方式删除迭代器，之后 it 会指向下一个有效的迭代器。

### 容器添加一个元素，迭代器会失效吗？

容器添加一个元素，一旦引起空间的重新配置，所有的迭代器将会失效。STL 中的容器只有 vector 、unordered_set 和 unordered_map 既拥有迭代器和空间重新配置机制。

### STL 迭代器是什么？TODO: 迭代器是怎么实现的？

迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，另外，STL 的迭代器可以作为容器与 STL algorithm 的粘合剂。

### STL 中的 sort 用什么排序？为什么插入排序？为什么堆排序？

数据量大时采用快排分段，然后归并。一旦分段后的数据量小于门槛 16，为避免快排的递归调用带来过大的开销，就改用插入排序。如果递归层次过深还会改用堆排序。

插入排序在面对接近有序的序列表现更好，堆排序是时间复杂度恒定为 nlogn。

### 哪些 STL 容器需要用到 sort 算法？

关系型容器底层采用 RB-Tree，所以不需要用到 sort 算法。序列式容器中的 stack、queue 和 priority-queue 都有特定的出入口，不允许用户对元素排序。剩下的 vector、deque，适用sort算法。

### TODO: 如何在共享内存上使用 STL 容器？

使用 placement new 在共享内存上创建容器，然后自定义容器分配器，使其在共享内存上分配内存？

### TODO: STL 的几大组件？

### TODO: STL 配置器？