<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

[toc]

# C++ STD

### string 写时复制？

C++11 之前的标准并没有规定 string 的实现方式，所以各个编译器 C++11 之前 string 的实现都是写时复制。

写时复制一般采用引用计数来实现，会存在线程安全问题，多线程下的引用计数必须是原子操作。实现细节是：在复制字符串时，引用计数加 1；在写字符串时，如果引用计数大于 1，则先将引用计数减 1，然后复制出一个新的字符串。

C++11 标准规定：不允许 [] 导致之前的迭代器失效，这就使得写时复制的 string 不再符合 C++ 标准规范了。

C++11 之后的 string 采用实时拷贝加短字符优化，不同编译器的短字符优化不同。

GCC 中的短字符优化是：当 string 长度小于等于 15 时，使用栈上的空间；当长度大于等于 15 时，在堆上分配，使用之前的栈空间保存堆区的 capacity 大小。

### vector 内存如何管理？

vector 底层是一个动态数组，默认大小为 0，在插入新元素时会自动扩容。自动扩容就是申请一片新的内存空间，把旧内存空间中的数据复制到新的内存空间，然后释放旧的内存空间。

在扩容时使用未雨绸缪机制，VS 中以原 vector 空间大小的 1.5 倍扩容，GCC 以 2 倍扩容。

### vector 中迭代器会失效吗？

vector 在 insert 时，只要引起空间的重新配置，旧的迭代器会全部失效。

在 erase 时，会将删除元素后面的所有元素向前移动，所以删除元素后边的迭代器也都会失效，但 erase 函数返回下一个元素的迭代器，所以可以在 erase 时接收其返回值来避免迭代器失效。

### vector 中，为什么 VS 使用 1.5 被扩容，GCC 使用 2 被扩容？

空间和时间的权衡吧，空间分配的多，扩容的次数小，时间复杂度就低。

另外 2 倍扩容的问题在于，每次扩容后的新尺寸必然刚好大于之前分配的总和，也就是说，即使之前分配的空间都是连续的，也不可能被使用，这样对内存不友好。

gcc 可能考虑到 vector 每次扩容所分配的内存都是连续的的概率很小，所以采用 2 倍扩容？？？

### vector 扩容会产生什么影响？怎么避免？

vector 频繁扩容会影响程序效率并会造成过多内存碎片，可以合理的使用 resize() 和 reserve() 方法避免 vector 自动扩容。

size() 返回已使用空间的大小，capacity() 返回总空间的大小，capacity() - size() 是未使用的空间大小。resize() 改变会改变 size() 和 capacity 的大小，reserve() 只会改变 capacity() 的大小。capacity() 的大小只增不减，如果想缩容的话，可以调用 shrink_to_fit() 将 capacity() 减少到 size()，这将会发生重新分配，所有的迭代器将失效。

### vector 扩容机制为什么不使用类似 c 的 realloc() 在尾元素后面的空间申请内存？

c++ 标准库容器的动态内存分配是交给分配器 Allocator 类处理的。对于默认分配器 std::allocator，有的版本实现是对 malloc/free 做了一层封装，但有的版本是自己做了内存池，可能不支持 realloc。如果是定制化的分配器，也可能不支持 realloc。

c 标准库的 realloc 有可能在原地扩容或缩容，有时也需要重新分配新内存空间，并且是直接按位浅拷贝的。对于 POD 类型这样用没问题，对于非 POD 类型这样做很危险。

vector 底层的原理是先用分配器分配出空间，然后有创建对象的需要时使用 placement new 显式调用构造函数。销毁对象时需要显式调用析构函数，最后在用分配器释放内存。简单理解就是如下：

```cpp
T * raw = (T*) malloc(sizeof(T) * N); // 分配内存
new (&raw[0]) T(); // 用 placement new 显式调用构造函数
raw[0].~T(); // 显式调用析构函数
free(raw); // 释放缓冲区
```

c++11 起 vector 扩容时是把 vector 中的元素移动构造过去。

### vector 删除元素后会释放空间吗？

vector 中的 erase 只能删除元素，不能改变总容量大小，vector 是不能缩容的，如果想要缩容，可以使用 deque 容器。另外可以调用 shrink_to_fit() 将 capacity() 减少到 size()，这将会发生重新分配，所有的迭代器将失效。

### vector 如果扩容原空间拷到新空间时有新元素插入会发生什么?

stl 中的所有修改操作都不是线程安全的，都不是原子性操作。如果多线程同时插入新元素，可能会导致未知错误。

### vector 通过下标访问？越界访问会怎样？

通过下标访问 vector 中的元素时，不会做边界检查，即使越界。如果想要边界检查，可以使用 at 函数。

### set 和 unordered_set 的区别？

set 和 unordered_set 都是集合，都不允许元素重复，另外 set 是排序特性，底层使用 RB-Tree，增删查的时间复杂度都是 O(logn)，unordered_set 没有排序特性，底层使用哈希表，增删查的时间复杂度都是 O(1)。另外 hashtable 会有无法处理的类型，这就需要自己实现 hash 函数。

在实际开发中，数据量不大的情况下，权衡是否需要排序功能，如果需要则使用 set，如果不需要则使用 unordered_set。

在海量数据的情况下，需要考虑它们的底层实现。RB-Tree 的空间方面会保存一些红黑树的属性和节点指针，好处是不会有未使用的空间浪费，也不会重新分配空间。hashtable 底层采用数组保存，一般数组的大小一定是大于数据大小的，使用链表来解决哈希冲突，如果冲突过多 (8 个以上) 也会使用 RB-Tree 来提高性能，这将导致 hashtable 有一定的未使用空间浪费。并且 hashtable 会有扩容机制，扩容会导致重新分配内存，然后 rehash，如果海量数据，这里的成本将会很高，所以海量数据优先选择 set。但如果可以提前知道 hashtable 的大小，可以使用 reserve 来提前分配空间，将会避免 rehash。

### map 和 unordered_map 的区别？

与 set 和 unordered_set 区别一样，set 的 key 就是 value，而 map 则是 key-value。

### map 的插入方式有哪些？

1. 使用 insert 插入 pair 数据、make_pair 数据、value_type 数据。

2. 使用数组方式插入数据。

### map 的 find 与 [] 下标访问？访问下标越界？

map 的 find 函数使用 key 执行查找，存在返回迭代器，不存在返回尾迭代器。

下标访问时，会使用 key 执行查找，并返回相应的值，如果该 key 不存在，则会插入一个默认值。

### unordered_map 怎么解决 hash 冲突和扩容？

unordered_map 使用数组作为 hash 桶，采用开链法来解决 hash 冲突，如果链表元素大于 8 个，则改为红黑树来提高性能。

当容器添加元素时，会判断当前元素的数量，如果大于等于阈值，则会启动扩容机制，需要重新分配内存和 rehash。

### 容器删除一个元素，迭代器会失效吗？

顺序容器使用 erase 删除一个元素，不仅会使删除的迭代器失效，而且被删除元素之后的所有元素会往前移动，所以后面所有的迭代器都会失效，list 除外，所以不能使用 erase(it++) 的方式，但顺序容器的 erase 的返回值是下一个有效的迭代器。

关联容器使用 earse 删除一个元素，只是被删除元素的迭代器失效，erase 的返回值是 void，可以采用 earse(it++) 的方式删除迭代器，之后 it 会指向下一个有效的迭代器。

### STL 迭代器是什么，怎么实现的？

迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，另外，STL 的迭代器可以作为容器与 STL algorithm 的粘合剂。

### STL 中的 sort 用什么排序？为什么插入排序？为什么堆排序？

数据量大时采用快排分段，然后归并。一旦分段后的数据量小于门槛 16，为避免快排的递归调用带来过大的开销，就改用插入排序。如果递归层次过深还会改用堆排序。

插入排序在面对接近有序的序列表现更好，堆排序是时间复杂度恒定为 nlogn。

### 哪些 STL 容器需要用到 sort 算法？

关系型容器底层采用 RB-Tree，所以不需要用到 sort 算法。序列式容器中的 stack、queue 和 priority-queue 都有特定的出入口，不允许用户对元素排序。剩下的 vector、deque，适用sort算法。

### TODO:如何在共享内存上使用 STL 容器？

使用 placement new 在共享内存上创建容器，然后自定义容器分配器，使其在共享内存上分配内存？
