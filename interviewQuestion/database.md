<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-12-05
-->

[toc]

# 数据库

## 数据库

### 什么是数据库范式？

数据库范式是为了避免数据库冗余数据而定义的一种规范，更高级的范式是在上一级范式的基础上再增加一些条件。

第一范式是保证表中的字段不可再分；

第二范式是在第一范式的基础上，保证表中必须有主键，并且所有的字段都依赖主键；

第三范式是在第二范式的基础上，保证表中没有传递依赖，也就是说保证表中的字段只依赖于主键，而不依赖于其它字段。

数据库范式只能保证数据不冗余，有时为了提高运行效率，需要反范式化，降低范式标准，适当保留冗余数据，达到以空间换时间的目的。例如，订单表中的金额可以由单价和数量计算出，但增加金额这个冗余字段，可以提高查询统计的速度。

### 什么是事务？

事务( transaction) 就是一个对数据库操作的序列，是一个不可分割的工作单位，这个序列里面的操作要么全部执行，要么全部不执行。一个事务必须具有原子性、一致性、隔离性和持久性。

原子性是指一个事务中的所有操作，要么全部执行，要么全部不执行，不会结束在中间某个环节。如果事务在执行过程中发生错误，会被回滚 (Rollback) 到事务开始前的状态，就像这个事务从来没有执行过一样。

一致性是指在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的数据必须完全符合所有的预设规则，这包含数据的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

隔离性是指数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交 (Read uncommitted)、读提交 (read committed)、可重复读 (repeatable read) 和串行化 (Serializable)。

持久性是指事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 事务并发的问题？

1. 脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。

2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。

3. 幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

4. 丢失修改 (Lost to modify)：事务 A 和事务 B 读取了同一数据，然后事务 A 将数据减 1，事务 B 将数据减 1，最终结果 数据只减了 1。事务 A 修改的数据丢失。

总结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

### 什么是乐观锁？

乐观锁本质上是不加锁实现了并发，只有在更新时验证数据是否被其他线程更新，吞吐量较高，适用于多读场景。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。

### 请说下你对 mysql 架构的了解？

```txt
---------------------------------
        客  户  端
------------|--------------------
            v              连接层
        连  接  器
--------|-------|----------------
        v       v          服务层
    查询缓存   解析器
                |
                v
              优化器
----------------|----------------
                v          存储层
        存储引擎1, 存储引擎2
```

第一层为连接层，主要是连接处理、授权认证、安全等。

第二层为服务层，功能包括缓存、查询解析、分析、优化及所有内置函数 (例如，日期、时间、数学和加密函数)、存储过程、触发器、视图等。

第三层为存储引擎层，该层负责 mysql 中数据的存储和提取，支持多个或多种存储引擎。

### 说一下一条 sql 语句在 mysql 框架中的执行流程？

1. 客户端发送 sql 语句，服务器连接层接收 sql 语句。

2. 查询缓存，如果缓存中存在，返回结果，否执行下一步。

3. 解析器解析 sql、预处理、优化 sql、生成执行计划。

4. mysql 在存储引擎中执行计划，将结果返回给客户端。

### 索引是什么？

索引是帮助数据库高效获取数据的数据结构。数据库索引好比是一本书前面的目录，能加快数据库的查询速度。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中 (可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中)。

索引的缺点是：1. 占据磁盘空间。2. 写操作，需要同步更新索引。

在 MySQL 中使用较多的索引有 Hash 索引 和 B+ 树索引等。B+ 树索引又可分为普通索引、主键索引、唯一索引、组合索引、全文索引、前缀索引、聚簇索引、覆盖索引、空间索引等。

主键索引：索引列中的值必须是唯一的，不允许有空值。

唯一索引：索引列中的值必须是唯一的，允许有空值。

组合索引：多个字段排序的联合索引，需要遵循最佳左前缀原则。

全文索引：字段较长时，可以提取出关键字作为索引。

前缀索引：字段较长时，可以使用前缀作为索引。

聚簇索引：聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，聚簇索引的叶子节点就是数据节点。

覆盖索引：在叶子结点中已经包含要查询的数据，这样就可以不用回表查询了。

空间索引：MySQL在 5.7 之后的版本支持了空间索引，支持 OpenGIS 几何数据模型。

### 什么是聚簇索引？

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引。

聚簇索引和非聚簇索引的区别是：聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

### 哈希索引有什么局限性？

哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如：快速的哈希查找。

### 为什么选择 B+ 树，而不是 B 树

1. B+ 树叶子结点形成了双向有序链表，可以进行区间查找，而 B 树不行。

2. B+ 树非叶子结点不保存数据，加载磁盘页时，B+ 树加载的都是索引节点 (不含数据)，所以查找过程中的磁盘 I/O 次数会大大减小。

### 为什么不用红黑树？

红黑树是二叉树，高度要比 B 树高一些。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为O(h)，效率明显比 B-Tree 差很多。另外也能进行区间查找。

### 什么是索引失效？什么情况下会失效？

索引失效的意思是，数据库查询放弃使用索引而进行全表是扫描。

1. where 语句的 != 、<>、判 null、表达式 (运算、函数) 等操作，会导致索引失效。

2. 条件中使用了 and，但相关列不符合最佳左前缀。like 查询以 % 开头。

### 查询性能的优化方法？

1. 只返回必要的行和列，尽量不使用 select * 语句，使用 LIMIT 来限制返回的数据。

2. 缓存重复查询的数据。

3. 建立索引，并避免索引失效。

4. 利用索引来做排序，尽量减少数据库的压力。

### 什么是最佳左前缀原则？

当 B+ 树的数据项是复合的数据结构时，底层的有序双向链表会根据第一字段排序，第一字段相同的会根据第二字段排序，以此类推。如果越过第一字段，去找第二字段，则链表是无序的，会导致引失效。

### mysql 两种数据库引擎

MyISAM 是 MySQL 默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT (插入)或 UPDATE(更新) 数据时即写操作需要锁定整个表，效率便会低一些。不过和 Innodb 不同，MyISAM 中存储了表的行数，于是 SELECT COUNT(*) FROM TABLE 时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么 MyISAM 也是很好的选择。

Innodb 引擎提供了对数据库 ACID 事务的支持，并且实现了 SQL 标准的四种隔离级别。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于 MySQL 后台的完整数据库系统，MySQL 运行时 Innodb 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持 FULLTEXT 类型的索引，而且它没有保存表的行数，当 SELECT COUNT(*) FROM TABLE 时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用 Innodb 引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表。

区别：

1. MyISAM 是非事务安全的，而 InnoDB 是事务安全的
2. MyISAM 锁的粒度是表级的，而 InnoDB 支持行级锁
3. MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引
4. MyISAM 相对简单，效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM
5. MyISAM 表保存成文件形式，跨平台使用更加方便

应用场景：

MyIASM 管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量 select 操作，应该选择 MyIASM。

InnoDB 用于事务处理，具有事务支持等特性，如果在应用中执行大量 insert 和 update 操作，应该选择 InnoDB。

### mysql 事务？

在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。事务就是一个对数据库操作的序列，是一个不可分割的工作单位，事务里面的所有操作要么全部执行，要么全部不执行。

一个事务是必须满足 4 个条件 ACID：原子性 (Atomicity，或称不可分割性)、一致性 (Consistency)、隔离性 (Isolation，又称独立性)、持久性 (Durability)。

**mysql 事务控制语句：**

BEGIN 或 START TRANSACTION 显式地开启一个事务；

COMMIT 也可以使用 COMMIT WORK，二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；

ROLLBACK 也可以使用 ROLLBACK WORK，二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；

SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；

RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；

ROLLBACK TO identifier 把事务回滚到标记点；

SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

### ACID 实现原理？

事务的原子性是通过 undo log 来实现的；

事务的持久性性是通过 redo log 来实现的；

事务的隔离性是通过 (读写锁+MVCC) 来实现的；

事务一致性是通过原子性，持久性，隔离性来实现的！

### mysql 隔离级别分别都是什么？

事务隔离级别|脏读|不可重复读|幻读
:-|:-:|:-:|:-:
读未提交 (read-uncommitted)|是|是|是
读提交 (read-committed)|否|是|是
可重复读 (repeatable-read)|否|否|是
串行化 (serializable)|否|否|否

1. 事务隔离级别为读提交时，写数据只会锁住相应的行。

2. 事务隔离级别为读提交时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是 next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。

3. 事务隔离级别为串行化时，读写数据都会锁住整张表。

4. 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。

### mysql MVCC 实现原理？

MVCC 可以在大多数情况下代替行级锁，使用 MVCC 能降低其系统开销。

MVCC 实际上就是通过数据的隐藏列和回滚日志（undo log），实现多个版本数据的共存。这样的好处是，使用 MVCC 进行读数据的时候，不用加锁，从而避免了同时读写的冲突。
