<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

[toc]

# C++

### 引用和指针的区别？

1. 引用是变量的别名；指针是一个指针变量，保存的是对象的首地址。

2. 引用在定义时必须初始化，并且不能够改变；指针在定义时不一定要初始化，并且指向的对象可以改变。

3. 引用访问一个变量是直接访问；指针访问一个变量是间接访问。

4. 有多级指针，但是没有多级引用，只有一级引用。

5. 指针和引用的自增运算结果不一样，引用是引用的变量值加 1，指针是指向下一个空间。

6. sizeof 引用得到的是所引用的变量对象的大小，sizeof 指针得到的是指针本身的大小。

7. 作为参数时也不同，传指针的本质是传值，传递的值是指针的地址；传引用的本质是传地址，传递的是变量的地址。

8. 引用底层是通过指针实现的，相当于一个匿名指针。汇编代码中指针和引用的代码是一样的，也会分配内存空间。

### static 关键字？c 和 c++ 中的 static 有什么区别？

1. static 具有隐藏属性，在编译多文件时，全局变量和全局函数具有全局可见性，而 static 修饰的全局变量和全局函数只在当前文件可见。

2. static 具有持久化属性，static 修饰的变量(包括局部变量)存储在静态数据段，在主程序之前，编译器已经为其分配好了内存。在 C 语言中，static 变量只在程序刚开始运行时初始化一次，默认初始化为 0，生命周期与程序生命周期一致；在 C++ 中，只在程序执行到相关代码时初始化一次，默认初始化为 0，这是因为 C++ 引入类后，要进行初始化必须执行相应的构造函数，在构造函数中经常会需要进行某些程序中进行的特定操作，并非简单的分配内存。所以 c++ 标准定为静态局部对象是首次用到时才会构造，并通过 atexit() 来进行管理。在程序结束时，按照构造顺序反方向进行逐个析构，所以 c++ 中是可以使用变量对静态局部变量进行初始化的。

3. 类中的 static 成员变量属于整个类所拥有，无论创建了多少个对象，程序都只创建一个副本，也就是说，类的所有对象共享同一个静态成员。并且不能在类的声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存。对于类的静态成员变量，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句只需指出类型，使用类名和域作用符，不使用关键字 static。初始化语句是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包含在多个文件中。如果在头文件中进行初始化，将会出现多个初始化语句的副本，从而引发错误。但经过实践得到，同时使用 static 和 const 修饰的 int 类型的成员变量可以在类内初始化。

4. 类中的 static 修饰的成员函数属于整个类所拥有，该函数不接受 this 指针，因此只能访问类的 static 成员变量。并且静态成员函数不能被 virtual 修饰，因为 static 不属于任何对象，所以加上 virtual 没意义。

### const 关键字？const 成员函数？const 和指针？

1. const 关键字可以防止一个变量被改变。在定义 const 变量时，通常需要进行初始化，因为初始化以后不能去改变它了。

2. 对于指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或者二者同时指定为 const。在 * 前指明 const 则是修饰指针所指的数据为 const，在 * 后指明 const 则是修饰指针为 const。

3. 对于函数来说，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值，一般常用在传引用参数时。

4. 对于类的成员函数，可以在参数的右括号后指定为 const 函数，则表明是一个常函数，不能修改类的成员变量。类的常对象，只能访问类的常成员函数，有时需要指定返回值为 const 类型，使得其返回值不为左值。

5. const 类型变量可以通过类型转换符 const_cast 将 const 类型转换为非 const 类型。

### mutable 关键字？

1. 如果需要在 const 成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为 mutable。即用 mutable 修饰的成员变量不受 const 成员方法的限制。

2. 可以认为 mutable 的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于 const_cast 的存在，这个概念很多时候用处不是很多了。

### extern 关键字？

1. 如果需要在一个文件中引用另一个文件的全局变量和全局函数，可以在该文件中使用 extern 声明，然后就可以引用了。

2. extern 修饰符可用于指示 c 或 c++ 函数的调用规范。比如在 c++ 中调用 c 库函数，就需要在 c++ 程序中 extern C 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候使用 C 函数规范来链接。这是因为 c 和 c++ 编译完成后在目标代码中命名规则不同。

### volatile 关键字？

volatile 是一个类型修饰符，它指示编译器它所修饰的对象不应该执行优化，程序每次读取变量都去内存中读取。一般用于多线程编程之间共享的变量。

volatile 总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值，在哪里使用，在哪里失效，分析结果可以用于常量合并，常量传播等优化，还可能会暂时使用寄存器中的值。如果其它并发程序更新了这个变量，可能会出现不一致的现象。

### 数值转字符串？字符串转数值？

字符串转数值，c 在 stdlib.h 头文件中定义了 atoi、atof、atol、atoll 函数，c++11 在 string 头文件中定义了 std::stoi、std::stof、std::stol、std::stoll 函数。

数值转字符串，c 在 stdio.h 头文件定义了 sprintf 和 snprintf 函数，c++11 在 string 头文件中定义了 std::to_string 函数，该函数重载了所有数值类型。

### C struct 和 C++ struct 区别？C++ struct 和 class 区别？

C 中的 struct 是用户自定义类型 (UDT)，没有访问权限，不能隐藏数据，也不能封装函数。在 C 中，一个结构标记声明后，必须在结构标记前加上 struct，才能做结构类型名。

c++ 中的 struct 是抽象数据类型 (ADT)，默认访问权限是 public，这是为了兼容 c，并且支持成员函数的定义，能继承，实现多态。与 c++ class 的区别是默认访问权限不同，class 的默认访问权限是 private。

### C++ class 默认提供哪些函数？

构造函数、拷贝构造函数、析构函数、赋值运算符。

### 类成员变量的初始化方式有哪些？有什么区别？为什么初始化列表会快一些？

类成员变量的初始化方式有赋值初始化和初始化列表。赋值初始化是程序在构造函数执行之前为变量分配空间，然后在构造函数体内通过赋值进行初始化；初始化列表是在冒号后使用初始化列表进行初始化，是在构造函数执行之前分配空间时捎带初始化的。赋值操作可能会产生临时对象，所以初始化列表比赋值更快。

《Effective C++》条款 4：构造函数最好使用成员初始化列表，而不要在构造函数体内使用赋值操作。

### 构造函数的执行顺序？多继承中的构造函数执行顺序？

一个派生类的构造函数的执行顺序如下：

1. 虚基类的构造函数，多个虚基类按照继承顺序执行构造。

2. 普通基类的构造函数，多个普通基类按照继承顺序执行构造。

3. class 类型的成员对象的构造函数，按照初始化顺序执行构造。

4. 派生类自己的构造函数。

析构函数与构造函数的执行顺序相反。

### 深拷贝与浅拷贝？

同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，这种情况称为浅拷贝。浅拷贝一般不会出现什么问题，但是当类中有指针，并且指针指向堆区内存，析构函数做了堆区内存释放处理，有可能导致悬空指针或多次释放同一堆区内存的问题。在这种情况下，应该自定义拷贝构造函数，自行给指针分配堆区内存，这就是深拷贝。

### new delete 和 malloc free 区别？operator new 和 operator delete？placement new？

new 在申请内存后会自动调用对象的构造函数。delete 先调用对象的析构函数然后释放内存。new 和 delete 需要成对使用。

malloc 和 operator new 一样，只申请内存，需要指明大小。free 和 operator delete 一样，只释放内存。malloc 和 free 成对使用，operator new 和 operator delete 成对使用。

placement new 在给定的内存空间上调用构造函数初始化，使用时需要在 new 关键字后加一个括号，括号里边是 placement-params，一般是指向缓冲区首地址的指针变量。

### new 出来的指针可以用 free 释放吗？

语法上可以，但 free 不会调用析构函数，如果析构函数需要处理堆区内存释放操作，那么会造成内存泄漏。这是一个有害无利的操作，所以开发人员应该约束自己不这么干。

### c++ 中的类型转换？

c++ 的类型转换除了隐式转换和兼容 c 的强制转换还引入了四种类型转换，分别是：

1. static_cast：静态转换，用于数值类型转换和派生类到基类的向上转换。

2. dynamic_cast：动态转换，可用于基类到派生类的向下转换，也可用于向上转换，编译器会执行类型检查，如果不匹配则返回空。

3. const_cast：常量转换，可用于转换指针或引用类型的 const 或 volatile 的属性。

4. reinterpret_cast：重新解析转换，用于具有危险属性的类型转换，比如将一个 int 类型转换为 包含两个 short 的结构体类型。这是最不安全的类型转换，也并不是支持所有的类型转换。例如，可以将指针类型转换为足以存储指针表示的整型，但不能将指针转换为更小的整型或浮点型；另一个限制是，不能用于函数指针和数据指针之间的转换。

### c++ 模板是什么？底层是怎么实现的？

c++ 中的模板是泛型定义，其中的泛型可用具体的类型替换。模板并不创建任何函数和类，而只是告诉编译器该如何定义函数。需要哪种具体类型，编译器将按模板模式创建这样的函数，并用具体类型替换泛型。

### 一个没有任何数据成员的类实例化之后占用空间大小是多少？

大小为 1，这是因为 c++ 不允许两个不同的对象用于相同的首地址。

### 什么是内敛函数？

编译器将使用 inline 函数代码替换函数调用，避免了普通函数入栈的成本。要使用 inline 特性，可以在函数声明前加上关键字 inline，或者在函数定义前加上关键字 inline，或者将定义直接写在类中。

内敛函数只是一个建议，编译器会判断该函数是否值得内敛，如果该函数体过大或有递归，则不将其作为内敛。

我们都知道宏替换会存在一定的问题，那是因为宏不能按值传递，内联函数可以避免这个问题。

### 构造函数和析构函数可否抛出异常？

1. c++ 只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在构造函数中发生异常，对象析构函数不会被调用，因此会造成内存泄漏。

2. 用智能指针对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源。

3. 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，c++ 会调用 terminate 函数让程序结束。

4. 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。

### 类如何实现只能静态分配或只能动态分配？

将 new 运算符重载为 private 属性，就只能静态分配了。

将构造函数设置为 protected 属性，就不能静态分配了，可以用子类或者友元动态创建。

### 什么是多态？c++ 怎么实现多态？

多态是指同一个方法在派生类和基类中的行为是不同的。也就是说，方法的行为取决于调用方法的对象。这种较复杂的行为被称为多态 (具有多重形态)。

C++ 有两种方法实现多态：

1. 在派生类中重定义基类的函数；

2. 使用虚函数。

### 什么是虚函数？

使用 virtual 修饰的成员函数被称为虚函数。虚函数使其行为可以在派生类中覆盖基类的成员函数，即使没有关于该类实际类型的编译时信息，进行覆盖的行为仍然保留。当使用到基类的指针或引用调用虚函数时，将会调用派生类中的虚函数。

### 如何调用基类的虚函数？

虚函数调用在使用有限定名字查找 (即函数名出现在作用域解析运算符 :: 的右侧) 时被抑制。

因此，想要调用基类的虚函数，只需指明域就可以了，这时就变成静态绑定了。例如：`a->Base::vfun();`

### 虚函数的工作原理？

编译器给每个对象添加了一个隐藏成员，该隐藏成员中保存了一个指向函数地址数组的指针，该指针存储在类的最开始的地方，这种数组称为虚函数表 (virtual function table, vtbl)。

虚函数表按照虚函数在类中的声明的顺序存储了所有虚函数的地址，vtbl 保存在只读数据段中，在内存中只有一个副本，类的所有对象共享。

调用虚函数时，程序将查看存储在对象中的 vtbl 地址，然后转向相应的函数地址表。如果使用类声明中定义的第 i 个虚函数，则程序将使用数组中的第 i 个虚函数地址，并执行具有该地址的函数。

### 虚函数有什么不足吗？

使用虚函数时，在内存和执行速度方面有一定的成本，包括：

1. 每个对象都将增大，增大量为存储地址的空间。

2. 对于每个类，编译器都创建一个虚函数地址表(数组)。

3. 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

### 构造函数可以是虚函数吗？

1. 是存储空间角度来看，有虚函数的类对象会在类的起始地址隐式定义一个指向函数地址数组指针，显然这个指针存储在对象的内存空间上，而类对象是在构造函数分配空间的，虚函数表指针也是在构造函数中初始化的。假设构造函数是虚的，就必须通过查找虚函数表来调用，但此时对象还没有实例化，没有虚函数表指针，这样就找不到虚函数表，所以构造函数不能是虚函数。

2. 从使用角度，虚函数主要用于使用基类指针或引用调用派生类重写基类的函数，而构造函数只在创建对象的时候主动调用的，并且创建对象的时候必须显示声明类型，所以不可能存在使用基类指针或引用去调用构造函数的场景，所以构造函数定义为虚函数没有任何意义。

### 析构函数可以是虚函数吗？

析构函数应当是虚函数，除非类不用做基类。当使用基类指针或引用释放派生类对象时，如果析构函数不是虚函数，则会调用基类的析构函数，如果派生类有自己的堆区内存时，会造成内存泄漏。如果析构函数是虚函数，此时会先调用派生类的析构函数，释放掉派生类的堆区内存，然后由派生类的析构函数调用基类的析构函数。

### 虚函数可以声明为 inline 吗？

答：虚函数用于实现动态绑定，而 inline 函数用于提高运行效率。内敛函数的原理是，在编译期间，对调用内敛函数的地方的代码替换成函数代码，可以说明 inline 函数并没有函数入口地址。而虚函数的实现需要将函数入口地址保存在虚函数表中，所以虚函数不能声明为 inline。

### 可以在构造函数或析构函数中调用虚函数吗？为什么？

可以。但构造函数和析构函数都不使用动态联编，如果在构造函数和析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。因为先执行基类构造函数，派生类的数据还未初始化，此时虚函数指针指向基类的虚函数表，如果在基类的构造函数里调用虚函数，所以只会执行子类的虚函数版本。释放一个对象时，先执行派生类的析构函数，然后再执行基类的析构函数，在基类的析构函数中调用虚函数，派生类的数据成员已经释放，编译器肯定不允许调用派生类的函数。

### 多重继承？菱形继承？

类 D 同时继承 B 和 C，B 和 C 又继承自 A 体系下，虚表在各个类中的布局如何？如果类 B 和类 C 同时有一个成员变了 m，m 如何在 D 对象的内存地址上分布的？是否会相互覆盖？虚函数会覆盖吗？

菱形继承时，顶端的基类应该使用虚继承，防止底端的派生类包含两份顶端的基类。c++ 的继承都不会覆盖，都可以使用域作用符访问子类的变量和函数；如果派生类有定义，则不存在歧义，默认使用派生类的变量或函数；如果虚函数存在歧义，则编译会报错，否则是访问歧义，访问时必须使用与域作用符访问，否则编译会报错。

## 你知道的 c++11 特性有哪些？

initializer_list、final、voerride、=default、=delete、auto、range-based、thread、thread_local、mutex、condition_variable、atomic、unique_ptr、shared_ptr、weak_ptr

## lambda 表达式是什么？有什么好处？

lambda 其实就是定义一个函数，它与函数的区别是，它可以在函数内定义，即写即用。

**lambda 有什么好处？**

可以从距离、简洁、效率和功能四个方面讨论。

距离上说，函数内部不能定义函数，但可以定义 lambda，因此 lambda 定义一般在使用的附近，这样就无需翻阅多页源代码来查看或修改函数的参数和实现；

从代码简洁是来说，函数符代码比函数和 lambda 代码更繁琐，另外如果需要使用同一个 lambda 多次，可以为 lambda 指定一个名字；

从效率来说，函数指针方法阻止了 inline，而函数符和 lambda 通常不会阻止 inline；

从功能上来说，lambda 可以访问作用域内的任何动态变量，可以按值访问，也可以按引用访问，还可以混合两种方式。

## 智能指针是什么？有几种？分别什么时候用？分别是怎么实现的？

使用智能指针可以很大程度避免内存泄漏，c++ 提供了 4 种智能指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr，其中后三个是 c++11 引入的，auto_ptr 已经被 c++11 弃用。它们实际上都是是类模板，采用 RAII (资源获取即初始化) 的思想来管理指针，通过类的构造函数和析构函数实现自动释放资源。

auto_ptr 是 c++98 引入的独占式所有权智能指针，在 c++11 中弃用，c++17 中移除。它的特点是，在赋值后，旧的 auto_ptr 会失去所有权，如果再次使用旧的 auto_ptr 会出错。另外 auto_ptr 只支持 new 和 delete，不支持 new[] 和 delete []。

unique_ptr 是 c++11 引入用来代替 auto_ptr 的独占式所有权智能指针。它只能将右值 unique_ptr 赋给另一个 unique_ptr，可使用 std::move 将一个左值 unique_ptr 赋值给另一个 unique_ptr。另外 unique_ptr 支持 new[] 和 delete[]。

unique_ptr 的实现需要删除拷贝构造和赋值运算符，提供移动构造和移动赋值，另外还需要重载 * 和 -> 操作符。

shared_ptr 是共享式拥有所有权智能指针。多个 shared_ptr 可以指向同一个对象，底层采用引用计数，对象资源会在最后一个 shared_ptr 销毁时释放。

shared_ptr 的实现需要在构造和拷贝构造函数中引用计数加 1；在析构函数中引用计数减 1，若引用计数为 0，则释放资源；重载赋值操作符中左边的引用计数减 1，右边的引用计数加 1，另外还需要重载 * 和 -> 操作符。

weak_ptr 是为了解决 shared_ptr 循环引用产生死锁导致资源无法释放的问题，它是一种弱引用智能指针，用来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用计数的增减。

在实际开发过程中，如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr，如果不需要，则使用 unique_ptr。如果两个对象相互持有对方的指针，则应搭配使用 shared_ptr 和 weak_ptr。

## 右值引用是什么？move 函数是什么？什么时候用？forward 函数是什么？什么时候用？

在 c++ 中有变量名的值称为左值，无变量名的值称为右值，右值只能出现在等号右边。

在函数传参时，从性能角度来看，左右值引用没区别，都可以避免拷贝。但右值引用可以直接引用右值，也可以通过 std::move 引用一个左值，而左值只能引用左值，const 左值引用可以引用右值，但无法修改，所以左值引用在函数传参时具有一定的局限性。

std::move 函数是传入一个左值，返回该左值的右值引用，相当于将一个左值类型转换为右值引用，move 这个名字具有迷惑性，实际上它并没有真正的 move。

在 c++11 后，右值引用和 std::move 函数被广泛用于 stl 中实现移动语义，调用移动构造或移动赋值，避免拷贝，从而提升性能。一般移动构造的实现是先执行一个浅拷贝，然后右边的对象清除，也就是说，新对象指向了旧对象的资源，旧对象不在拥有资源，这里的资源一般指的是堆区内存。

在实际开发中，只有当一个类实现了移动构造或移动赋值，然后该类的一个旧对象需要赋值给一个新对象，并且旧对象不再使用或者想要 clear 时，才需要使用右值引用。

std::forword 是一个函数模板，既可以转换出左值，也可以转换出右值。当 forword 传入的类型是左值时，将返回左值引用，否则将返回右值引用，相当于将一个变量转换为对应的左值或右值引用。forword 这个名字也具有迷惑性，实际上它并没有真正的 forword。

一般 std::forword 需要配合函数模板使用，这是因为类模板中的函数和普通函数在调用过程中都是有具体类型的，在有具体类型时，想用左值语义是不需要转换的，右值语义直接使用 move 转换。只有在函数模板模板参数下的 T&& 才能触发引用折叠，这是因为其中的 T 可以是 A&&、A& 或 const A&，当参数传进来时，函数不知道是哪种类型的参数，需要自己做类型检查，std::forword 会根据传入的类型 T，返回对应的左值语义或右值语义。
