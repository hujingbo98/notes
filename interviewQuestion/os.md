<!--
 * @Author : Hu Jingbo
 * @Date   : 2021-11-19
-->

[toc]

# 操作系统

### 什么是内核态和用户态？

为了防止操作系统本身及其它进程的 PCB 等信息遭受应用程序的破坏，操作系统将 CPU 的执行状态分为内核态和用户态。

* 内核态具有较高的特权，能执行一切指令，访问所有寄存器和存储区。

* 用户态具有较低特权的执行状态，只能执行规定的指令，访问指定的寄存器和存储区。

应用程序只能在用户态运行，可以调用操作系统提供的系统调用来访问系统资源。

### 什么是并行和并发？

同一个 CPU 在同一时刻只能执行一个指令

并行是指两个或多个事件在同一时刻发生，并行需要多处理器的支持。

并发是指两个或多个事件在同一时间间隔内发生，通常是指单核进行上下文切换、时间片轮转造成同时执行的现象。

### 进程是什么？为什么要有进程？

为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，引入了进程的概念。一个进程由 PCB、代码段和数据段三部分构成。进程是操作系统资源分配的最小单位。

### 什么是 PCB？

为了能使并发执行的每个程序 (含数据) 都能够独立的运行，操作系统为每个进程配置了一个专门的数据结构，称为进程控制块 (PCB, Process Control Block)。系统利用 PCB 来描述进程的基本情况和活动过程，进而控制和管理进程。

### 进程有哪些状态，它们之间是怎么转换的？

进程在运行时有三种基本状态：就绪态、执行态和阻塞态。

* 就绪态进程是指该进程已分配到除 CPU 以外的所有必要资源，只要得到 CPU，便可立即执行的状态。

* 执行态进程是指 CPU 正在执行的进程。

* 阻塞态是指正在执行的进程由于发生某事件 (如 I/O 请求、申请缓冲区失败等)，导致当前进程受阻的状态。

进程各种状态间的转换关系是：

* 就绪态进程在得到 CPU 之后进入执行态；

* 执行态进程在时间片用完后进入就绪态，如果因发生某事件，导致当前进程受阻，则进入阻塞态。

* 阻塞态进程，因阻塞事件完成 (如 I/O 请求完成)，则进入就绪态。

### 进程的内存空间是怎么组织和分布的？

* 正文段，也称代码段。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需要一个副本，另外，正文段常常是只读的，以防止程序由于意外而修改其指令。

* 初始化数据段，通常将此段称为数据段。它包含了程序中明确地赋非 0 初值的全局变量、静态变量。代码段不是只读的，在运行时变量的值是可以改变的。数据段还可细分为初始化只读区和初始化可读写区。

* 未初始化数据段，通常将此段称为 bss 段，这一名字来源于早期汇编程序一个操作符，意思是“由符号开始的块” (block started by symbol)。在程序开始执行之前，它包含了程序中初始化为 0 的和未初始化的全局变量、静态变量，内核将此段中的数据初始化为 0 或空指针。生命周期是整个进程的生命周期的变量都保存在数据段或 bss 段。

* 堆。通常在堆中进行动态内存分配，堆位于 bss 段末尾，并向高地址生长。

* 栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中，栈与对是相邻的，并向对方的方向生长，因此栈的内存地址是从高到低分配的，当栈指针触及到堆指针位置时，意味着堆栈空间已被耗尽。

* 内存映射段。该段保存共享库和共享内存的映射。

```txt
            栈
            内存映射段
            堆
            未初始化数据段 (bss 段)
            初始化数据段
            代码段
```

### 进程的通信方式有哪些？不同通信方式之间的区别和优缺点是什么？它们的实现原理是什么？

进程的通信方式有：无名管道、命名管道、消息队列、信号、信号量、共享内存、Socket。

### 无名管道

无名管道用于有血缘关系的进程之间，它是半双工的，如果要进行双工通信，则需要建立两个管道。

管道本质上是一个伪文件，实为环形队列的内核缓冲区。由两个文件描述符引用，一个表示读端，一个表示写端。规定数据从写端流入，从读端流出。

从管道读数据是一次性操作，数据一旦被读，便被丢弃，释放空间以便写更多的数据。

**无名管道的局限性：**

1. 只能用于有血缘关系的进程之间。

2. 数据自己读不能自己写，且数据一旦被读走，便被丢弃，不可反复读取。

4. 管道采用半双工通信方式，因此，数据只能在一个方向上流动。如果要进行全双工通信，则需要建立两个管道。

### 命名管道

用于没有血缘关系的进程之间的通信。

### 消息队列

独立于进程存在，进程间可以通过消息队列来传递数据，典型的模式是生产者-消费者模型。

### 信号

信号是软件中断，提供了一种处理异步事件的方法，由系统通知进程发生了某种类型的系统事件。

信号的特点是简单、携带信息量少、优先级高，使用在特定场景。一般不使用信号进行进程间通信，因为信号的优先级会打破原有进程的执行过程。

信号的产生条件：

* 当用户按某些终端键时，引发终端产生的信号。在终端上按 Ctrl+C 键通常产生终端信号 (SIGINT)。这是停止一个程序的方法。

* 硬件异常产生信号：除数为 0、无效的内存引用等。这些条件通常有硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无效内存引用的进程产生 SIGSEGV 信号。

* 进程调用 kill(2) 函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制：接收信号的信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。

* 用户可用 kill(1) 命令将信号发送给其它进程。此命令只是 kill 函数的接口。常用此命令终止一个失控的后台进程。

* 当检测到某种软件条件已发生，并应将其通知有关进程时也产生信号。这里指的不是硬件产生的条件，而是软件条件。例如 SIGURG (在网络连接上传来的带外的数据)、SIGPIPE (在管道的读进程已终止后，一个进程写此管道) 以及 SIGALRM (进程所设置的定时器已经超时)。

信号的处理方式：在某个信号出现时，可以告诉内核按下列 3 中方式之一进行处理：

1. 忽略此信号。有两种信号不能被忽略，他们是 SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：他们向内核提供了使进程终止或停止的可靠方法。另外如果忽略某些由硬件异常产生的信号，如非法内存引用或除以 0，则进程的运行行为是未定义的。

2. 捕捉信号。为做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可执行用户希望对这种事件进行的处理。注意，不能捕捉 SIGKILL 和 SIGSTOP 信号。

3. 执行系统默认动作。

### 常见的信号有哪些？

SIGINT：挂起进程

SIGKILL：终止进程

SIGSTOP：停止进程

### 系统如何将一个信号通知到进程？

例如，有两个进程 A、B，A 调用系统调用委托内核发送信号给 B。内核先检查 A 是否有权限发送此信号给 B，如果无权限，则忽略此信号；如果有权限，则设置 B 的 PCB 中的信号域中的对应的信号的位，之后后发送中断请求给 B，这样 B 进程就进入内核态，这时 B 根据信号表捕捉信号，将对应的信号处理函数地址压入用户栈栈顶，然后由内核态转入用户态，由于先弹出信号处理函数的地址，因此先执行信号处理函数，然后再弹栈，才是 B 中断时的状态。

### 共享内存

多个进程可以通过共享内存访问同一块物理内存，实现原理是将多个进程上的虚拟地址映射到同一块物理内存上，实现数据的共享。

因不涉及数据的拷贝，所以共享内存是最高效的 IPC。但在多个进程并发时，需要通过同步机制保护共享内存的访问。信号量和共享内存通常结合在一起使用，信号量用于同步对共享内存的访问。

### 共享内存被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大数量是多少？

共享内存被映射在内存映射段，处于堆和栈的中间。

Linux 下使用 ipcs -l 命令可查看系统支持的共享内存段数量，一般为 4096。

### 什么是僵尸进程、孤儿进程？它们分别是怎么产生的？是怎么解决的？

如果子进程退出后，它占用的进程描述符等资源没有被释放，只有等它父亲调用 wait() 或 waitpid() 获取到子进程的信息后，父进程会将子进程的资源释放。如果子进程的资源由于某种原因一直得不到释放，那么就一直处于僵尸状态，被称为僵尸进程。

当父进程先退出，子进程还在运行时，该子进程被称为孤儿进程。孤儿进程只是暂时的，系统会在父进程退出时启动寻父机制，首先在进程组中寻找，如果找不到就返回 init (pid = 1) 的进程作为父进程。

系统中如果驻留大量的僵尸进程会一直占用系统资源，解决的直接办法是杀死父进程，让它们变成孤儿进程，最后会被新的进程领养，新的父进程会例行检查子进程状态，释放僵尸进程的资源。

### 什么是守护进程，如何实现守护进程？

守护进程 (daemon) 是生存期长的一种进程，它们常常在系统引导装入时启动，仅在系统关闭时才终止。因为它们没有控制终端，所以说它们是在后台运行的。UNIX 系统有很多守护进程，守护进程程序的名称通常以字母“d”结尾。例如，syslogd 就是指管理系统日志的守护进程。

实现守护进程：

1. 调用 umask 将文件模式创建屏蔽字设置为一个已知值 (通常是 0)。

2. 调用 fork 创建子进程，然后调用 exit 使父进程退出。这样做实现了下面几点：(1) 父进程退出，将子进程变为孤儿进程，被领养，后在后台运行；(2) 虽然子进程继承了父进程的进程组 ID，但获得了一个新的进程 ID，这就保证了子进程不是一个进程组的组长。这是下一步 setsid 调用的先决条件。

3. 调用 setsid 创建一个新会话。这样做使调用进程：(1) 成为新会话的首进程；(2) 成为一个新进程组的组长进程；(c) 没有控制终端。

4. 将当前工作目录更改为根目录。从父进程处继承过来的当前工作目录可能在一个挂载的文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个挂载文件系统中，那么该文件系统就不能被卸载，否则会影响守护进程。

5. 关闭不在需要的文件描述符。这使守护进程不在持有从其父进程继承来的任何描述符。

6. 某些守护进程打开 /dev/null 使其具有文件描述符 0、1 和 2，这样，任何一个试图读标准输入，写标准输出或标准错误的库例程都不会产生任何效果。

### 线程是什么？为什么要有线程？

为了减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性，操作系统中引入线程。线程是 CPU 调度的最小单位。

### 线程间的同步/互斥方法有哪些？

1. 互斥锁：任意时刻，只能有一个线程获取互斥锁。

2. 读写锁：没有线程持有写锁时，任意多个线程可以获取读锁；仅当没有线程持有读锁时，才能获取写锁。

3. 条件变量：一个或多个线程等待某个条件为真，而将自己挂起；另一个线程使得条件成立，并通知等待的所有线程继续执行。为了防止竞争，条件变量总是和一个互斥锁结合在一起使用。

4. 信号量：信号量包含一个信号值，通常用在进程间的同步，因为线程间可以更方便的使用条件变量加互斥锁。

5. 记录锁：字节锁、行锁、表锁等。

6. 自旋锁：任意时刻，只能有一个线程获取自旋锁，但获取自旋锁失败后，会循环等待持有者释放锁。

7. 屏障：对于一组进程中的同步屏障意味着任何进程执行到此后必须等待，直到所有进程都达到此点才可继续执行下文。例如：分治法可以使用屏障进行最后的合并。

### 线程的通信方式有哪些？不同通信方式之间的区别和优缺点是什么？它们的实现原理是什么？

1. volatile 变量或原子变量：用于实现简单的变量共享，一般采用互斥锁实现。

2. 消息队列：用于实现消息传递，一般采用对消息数量加互斥锁实现。

3. 事件机制：用于实现信号传递，一般采用条件变量和互斥锁实现。

### 什么是死锁？死锁是怎么产生的？死锁产生的条件有哪些？

多个并发执行的程序，由于资源竞争或推进顺序不当导致无法继续推进的现象叫死锁。也就是说，在一组进程中，每一个进程都在等待其它进程才能引发事件，那么该组进程发生死锁。

死锁产生的原因：

1. 竞争不可抢占性资源引起的死锁。

2. 竞争可消耗资源引起死锁。

3. 并发程序推进顺序不当引起死锁。

产生死锁的条件有：

1. 互斥条件：即在一段时间内，某资源只能被一个进程占用。

2. 请求和保持条件：进程已经保持了一个资源，但又提出了新的资源请求，而该资源被其它进程占有。

3. 不可抢占条件：进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放。

4. 循环等待条件：在发生死锁时，必然存在一个进程-资源的循环链，即一组进程中的所有进程都在等待其它进程占用的资源。

### 如何避免死锁？

1. 破坏请求保持条件：当进程新的资源未得到满足时，释放已占有的资源。

2. 破坏循环等待条件：资源有序分配，为每类资源赋予一个序号，每个进程按序号递增请求资源，释放则相反。

3. TODO: 银行家算法：

4. 鸵鸟算法：传说中鸵鸟看到危险就把头埋在地底下。当对某一件事情没有一个很好的解决方法时，那就忽略它。例如在计算机操作系统中，当死锁真正发生且影响系统正常运行时，需要手动重启。

### TODO: 如何检测死锁？

查看堆栈？

### 进程和线程的区别？

多线程和多进程的区别，需要从 CPU 调度，上下文切换，数据共享，多核 CPU 利用率，资源占用，等等各方面回答。

1. 进程是操作系统资源分配的最小单位，线程是 CPU 调度的最小单位。

2. 进程运行在操作系统下，而线程运行在进程下。一个进程可以有一个或多个线程，但一个线程只属于一个进程。

3. 进程拥有独立的地址空间，多个线程共享进程的地址空间。因此，多个线程可以使用进程的地址空间，通过同步互斥的方式进行通信。进程间的通信需要使用系统 IPC 提供的内核缓冲区来进行通信。但线程不好的地方是独立性差，一个线程崩溃会导致该进程下的所有线程退出。

4. 进程需要操作系统为其分配 PCB、内存空间等系统资源，而线程只需为其分配一个栈区和少量寄存器即可。

5. 进程的 CPU 调度需要进行进程上下文切换，保留当前进程的 CPU 环境，设置新进程的 CPU 环境等。而线程的调度只需保存和设置少量的寄存器，调度代价远小于进程。因此，线程的 CPU 利用率远高于进程。

6. 进程和线程都可实现并发，都可用于多核。但多进程可以进程多机分布，多线程不行。

### 哪些是线程私有的？

线程私有的有栈区、寄存器和线程局部存储 TSL，其它都是共有的。

线程的栈区可以由进程堆顶部向下分配，也可以从栈底部向上分配，无论如何分配，其大小是固定的。linux 可以使用 ulimit -s 命令查看栈的大小，一般为 8 M。

### 进程和线程间的同步有什么区别？

进程之间的地址空间不同，同步时需要将锁放在内核缓冲区中实现。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。

### 什么时候需要使用多进程？什么时候需要使用多线程？

如果需要多机部署的情况下应使用多进程。

一般情况下耗时较长的 I/O 操作使用多线程 + 异步来处理，可以提高并发量。对于耗时较长的逻辑，可以采用多线程进行加速。

### 各类异步机制有哪些？它们之间的区别和适用范围是什么？

1. 多线程 + 线程池：直接用线程来处理工作，适用于处理耗时较长的作业。

2. I/O 复用或事件回调：一般采用生产者消费者模式实现，可以避免多线程的时空开销，提高 CPU 使用率。一般的 I/O 操作，并作业耗时较短时，适用该方法。

异步的好处：

1. 可以立即给调用方返回初步的结果。

2. 可以延迟给调用方返回最终结果，在此期间可以执行更多工作，避免阻塞。

3. 异步流程可以将多次调用的结果统一返回给调用方，减少网络负担。

### 函数参数入栈顺序，函数栈帧内存是怎么分布的？

函数参数是从右向左的顺序入栈的。

当前帧的参数和返回地址，保存在调用者帧的最后。每个栈帧的两端以两个指针界定，寄存器 %ebp 为帧指针，寄存器 %esp 为栈指针。当程序运行时，栈指针可以移动，因此大多数信息的访问都是相对于帧指针的。

### 什么是字节对齐？为什么要字节对齐？字节对齐为什么可以提高 cpu 访问速度？

字节对齐是字节按照一定规则在空间上排列。它可以提高 cpu 访问速度。

在 32 位系统下，cpu 一次可以访问 32 位，也就是 4 个字节，并且每次访问的首地址必须是 4 的倍数。

假如，一个 int 对象 n 的地址为 0，cpu 一次访问就可以将其读取出来；如果 n 的地址为 2，cpu 需要访问首地址为 0 的 4 个字节和首地址为 4 的 4 个字节，经过裁剪才能得到这个 int 对象。

struct 是怎么对齐的？

1. pragma pack 是指定对齐值，结构体变量大小是自身对齐值，有效对齐值取其中最小的一个。

2. 结构体变量的首地址，能够被其有效对齐值大小所整除。

3. 结构体每个成员相对结构体首地址的偏移都是有效对齐值大小的整数倍。

4. 结构体的总大小为结构体中最大成员大小的整数倍。

## FQS & Solution

### 什么是内存泄漏？如何定位？如何避免？

内存泄漏是指程序中动态分配的内存，由于某种原因找不到了，从而导致无法释放。

内存泄漏如何定位？

1. 定制 new 和 delete。

2. 使用内存检测工具，如 valgrind；

内存泄漏如何避免？

1. 基类的虚构函数设为虚，在虚构函数中释放该类的所有堆区内存。

2. 自定义资源管理类来实现资源的申请和释放；

3. 使用 stl 智能指针或利用 RAII 和引用计数自己实现智能指针。

### 实现定时器有哪几种方式？优缺点是什么？分别什么时候使用？

分析定时器的需求？

1. 在 n 秒后执行一个任务 T
2. 每隔 n 秒执行一次任务 T
3. 取消一个定时器任务

简化需求得到的接口有：

1. 添加一个定时器，可设置定时器过期时间、是否重复或重复次数
2. 删除一个定时器

分析存储定时器的数据结构：

上述接口需要添加、删除和查询最近需要执行的任务，可以使用红黑树、优先队列 (最小堆)、跳表和哈希时间轮。

红黑树的插入、删除、查找的时间都是 O(logn)；

优先队列的的插入和删除时间是 O(logn)，查找时间是 O(1)；

跳表类似于红黑树；哈希时间轮的性质类似钟表指针。

这几种方式，现在流行的开源框架都各有采用，比如，Libevent 使用最小堆实现，Linux 内核使用时间轮实现。

最小堆定时器的实现思路：

1. 使用一个结构来保存定时器对象的数据，包括过期时间、回调函数等；

2. 所有的定时器对象保存在一个优先队列里，键值为执行时间；

3. 添加定时器即向优先队列中添加新项；

4. 删除定时器可以使用惰性删除；

5. 按照固定的时间间隔来 tick，每次 tick 都需要看看有没有需要执行的定时器对象；

6. 因为对象有优先队列管理，因此，当队首元素不需要执行时，后面的元素都不需要执行；

7. 一个对象需要执行时，可能需要将其删除，也可能需要重复执行，则需要设定好时间后再次添加。

时间轮定时器的实现思路：

时间轮是一个比较巧妙的 hash 结构，性质类似于钟表指针。首先考虑一个简单的大小为 60 的数组 t，每一个元素表示对应 1 秒内事务的集合：第 0 秒需要处理的事务都在 t[0]，第 5 秒需要处理的事务都在 t[5]，以此类推。另外数组 t 的元素也可以是一个数组，这样就可以支持 毫秒级定时器了，数组 t 作为 分钟时间轮的元素，就可以支持 1 小时定时器了，以此类推。

### i++ 是原子操作吗？为什么？

不是，i++ 分为三步，从内存中读取 i 到寄存器，在寄存器中自增、然后写回到内存，这三个步骤都可以被中断分离。

### cpu 100% 怎么定位？

1. `top` 查看哪个进程导致的；

2. `pstack <pid>` 将进程的堆栈输出到文件；

3. `top -H -p <pid>` 查看哪些线程在占用 cpu；

4. 查看该线程的堆栈信息，找出问题。
